/*
Moodle Webservice API

Auto-generated OpenAPI spec for Moodle's Webservice API. Requires installation of the Catalyst RESTful API plugin: https://github.com/catalyst/moodle-webservice_restful.

API version: 4.3.4
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package moodleclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// ToolDataprivacyAPIService ToolDataprivacyAPI service
type ToolDataprivacyAPIService service

type ApiToolDataprivacyApproveDataRequestRequest struct {
	ctx context.Context
	ApiService *ToolDataprivacyAPIService
	toolDataprivacyApproveDataRequestRequest *ToolDataprivacyApproveDataRequestRequest
}

func (r ApiToolDataprivacyApproveDataRequestRequest) ToolDataprivacyApproveDataRequestRequest(toolDataprivacyApproveDataRequestRequest ToolDataprivacyApproveDataRequestRequest) ApiToolDataprivacyApproveDataRequestRequest {
	r.toolDataprivacyApproveDataRequestRequest = &toolDataprivacyApproveDataRequestRequest
	return r
}

func (r ApiToolDataprivacyApproveDataRequestRequest) Execute() (*CoreContentbankRenameContent200Response, *http.Response, error) {
	return r.ApiService.ToolDataprivacyApproveDataRequestExecute(r)
}

/*
ToolDataprivacyApproveDataRequest Approve a data request

Approve a data request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolDataprivacyApproveDataRequestRequest
*/
func (a *ToolDataprivacyAPIService) ToolDataprivacyApproveDataRequest(ctx context.Context) ApiToolDataprivacyApproveDataRequestRequest {
	return ApiToolDataprivacyApproveDataRequestRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreContentbankRenameContent200Response
func (a *ToolDataprivacyAPIService) ToolDataprivacyApproveDataRequestExecute(r ApiToolDataprivacyApproveDataRequestRequest) (*CoreContentbankRenameContent200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreContentbankRenameContent200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolDataprivacyAPIService.ToolDataprivacyApproveDataRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_dataprivacy_approve_data_request"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolDataprivacyApproveDataRequestRequest == nil {
		return localVarReturnValue, nil, reportError("toolDataprivacyApproveDataRequestRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolDataprivacyApproveDataRequestRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolDataprivacyBulkApproveDataRequestsRequest struct {
	ctx context.Context
	ApiService *ToolDataprivacyAPIService
	toolDataprivacyBulkApproveDataRequestsRequest *ToolDataprivacyBulkApproveDataRequestsRequest
}

func (r ApiToolDataprivacyBulkApproveDataRequestsRequest) ToolDataprivacyBulkApproveDataRequestsRequest(toolDataprivacyBulkApproveDataRequestsRequest ToolDataprivacyBulkApproveDataRequestsRequest) ApiToolDataprivacyBulkApproveDataRequestsRequest {
	r.toolDataprivacyBulkApproveDataRequestsRequest = &toolDataprivacyBulkApproveDataRequestsRequest
	return r
}

func (r ApiToolDataprivacyBulkApproveDataRequestsRequest) Execute() (*CoreContentbankRenameContent200Response, *http.Response, error) {
	return r.ApiService.ToolDataprivacyBulkApproveDataRequestsExecute(r)
}

/*
ToolDataprivacyBulkApproveDataRequests Bulk approve data requests

Bulk approve data requests

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolDataprivacyBulkApproveDataRequestsRequest
*/
func (a *ToolDataprivacyAPIService) ToolDataprivacyBulkApproveDataRequests(ctx context.Context) ApiToolDataprivacyBulkApproveDataRequestsRequest {
	return ApiToolDataprivacyBulkApproveDataRequestsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreContentbankRenameContent200Response
func (a *ToolDataprivacyAPIService) ToolDataprivacyBulkApproveDataRequestsExecute(r ApiToolDataprivacyBulkApproveDataRequestsRequest) (*CoreContentbankRenameContent200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreContentbankRenameContent200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolDataprivacyAPIService.ToolDataprivacyBulkApproveDataRequests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_dataprivacy_bulk_approve_data_requests"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolDataprivacyBulkApproveDataRequestsRequest == nil {
		return localVarReturnValue, nil, reportError("toolDataprivacyBulkApproveDataRequestsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolDataprivacyBulkApproveDataRequestsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolDataprivacyBulkDenyDataRequestsRequest struct {
	ctx context.Context
	ApiService *ToolDataprivacyAPIService
	toolDataprivacyBulkDenyDataRequestsRequest *ToolDataprivacyBulkDenyDataRequestsRequest
}

func (r ApiToolDataprivacyBulkDenyDataRequestsRequest) ToolDataprivacyBulkDenyDataRequestsRequest(toolDataprivacyBulkDenyDataRequestsRequest ToolDataprivacyBulkDenyDataRequestsRequest) ApiToolDataprivacyBulkDenyDataRequestsRequest {
	r.toolDataprivacyBulkDenyDataRequestsRequest = &toolDataprivacyBulkDenyDataRequestsRequest
	return r
}

func (r ApiToolDataprivacyBulkDenyDataRequestsRequest) Execute() (*CoreContentbankRenameContent200Response, *http.Response, error) {
	return r.ApiService.ToolDataprivacyBulkDenyDataRequestsExecute(r)
}

/*
ToolDataprivacyBulkDenyDataRequests Bulk deny data requests

Bulk deny data requests

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolDataprivacyBulkDenyDataRequestsRequest
*/
func (a *ToolDataprivacyAPIService) ToolDataprivacyBulkDenyDataRequests(ctx context.Context) ApiToolDataprivacyBulkDenyDataRequestsRequest {
	return ApiToolDataprivacyBulkDenyDataRequestsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreContentbankRenameContent200Response
func (a *ToolDataprivacyAPIService) ToolDataprivacyBulkDenyDataRequestsExecute(r ApiToolDataprivacyBulkDenyDataRequestsRequest) (*CoreContentbankRenameContent200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreContentbankRenameContent200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolDataprivacyAPIService.ToolDataprivacyBulkDenyDataRequests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_dataprivacy_bulk_deny_data_requests"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolDataprivacyBulkDenyDataRequestsRequest == nil {
		return localVarReturnValue, nil, reportError("toolDataprivacyBulkDenyDataRequestsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolDataprivacyBulkDenyDataRequestsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolDataprivacyCancelDataRequestRequest struct {
	ctx context.Context
	ApiService *ToolDataprivacyAPIService
	toolDataprivacyCancelDataRequestRequest *ToolDataprivacyCancelDataRequestRequest
}

func (r ApiToolDataprivacyCancelDataRequestRequest) ToolDataprivacyCancelDataRequestRequest(toolDataprivacyCancelDataRequestRequest ToolDataprivacyCancelDataRequestRequest) ApiToolDataprivacyCancelDataRequestRequest {
	r.toolDataprivacyCancelDataRequestRequest = &toolDataprivacyCancelDataRequestRequest
	return r
}

func (r ApiToolDataprivacyCancelDataRequestRequest) Execute() (*CoreContentbankRenameContent200Response, *http.Response, error) {
	return r.ApiService.ToolDataprivacyCancelDataRequestExecute(r)
}

/*
ToolDataprivacyCancelDataRequest Cancel the data request made by the user

Cancel the data request made by the user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolDataprivacyCancelDataRequestRequest
*/
func (a *ToolDataprivacyAPIService) ToolDataprivacyCancelDataRequest(ctx context.Context) ApiToolDataprivacyCancelDataRequestRequest {
	return ApiToolDataprivacyCancelDataRequestRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreContentbankRenameContent200Response
func (a *ToolDataprivacyAPIService) ToolDataprivacyCancelDataRequestExecute(r ApiToolDataprivacyCancelDataRequestRequest) (*CoreContentbankRenameContent200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreContentbankRenameContent200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolDataprivacyAPIService.ToolDataprivacyCancelDataRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_dataprivacy_cancel_data_request"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolDataprivacyCancelDataRequestRequest == nil {
		return localVarReturnValue, nil, reportError("toolDataprivacyCancelDataRequestRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolDataprivacyCancelDataRequestRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolDataprivacyConfirmContextsForDeletionRequest struct {
	ctx context.Context
	ApiService *ToolDataprivacyAPIService
	toolDataprivacyConfirmContextsForDeletionRequest *ToolDataprivacyConfirmContextsForDeletionRequest
}

func (r ApiToolDataprivacyConfirmContextsForDeletionRequest) ToolDataprivacyConfirmContextsForDeletionRequest(toolDataprivacyConfirmContextsForDeletionRequest ToolDataprivacyConfirmContextsForDeletionRequest) ApiToolDataprivacyConfirmContextsForDeletionRequest {
	r.toolDataprivacyConfirmContextsForDeletionRequest = &toolDataprivacyConfirmContextsForDeletionRequest
	return r
}

func (r ApiToolDataprivacyConfirmContextsForDeletionRequest) Execute() (*ToolDataprivacyConfirmContextsForDeletion200Response, *http.Response, error) {
	return r.ApiService.ToolDataprivacyConfirmContextsForDeletionExecute(r)
}

/*
ToolDataprivacyConfirmContextsForDeletion Mark the selected expired contexts as confirmed for deletion

Mark the selected expired contexts as confirmed for deletion

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolDataprivacyConfirmContextsForDeletionRequest
*/
func (a *ToolDataprivacyAPIService) ToolDataprivacyConfirmContextsForDeletion(ctx context.Context) ApiToolDataprivacyConfirmContextsForDeletionRequest {
	return ApiToolDataprivacyConfirmContextsForDeletionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolDataprivacyConfirmContextsForDeletion200Response
func (a *ToolDataprivacyAPIService) ToolDataprivacyConfirmContextsForDeletionExecute(r ApiToolDataprivacyConfirmContextsForDeletionRequest) (*ToolDataprivacyConfirmContextsForDeletion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolDataprivacyConfirmContextsForDeletion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolDataprivacyAPIService.ToolDataprivacyConfirmContextsForDeletion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_dataprivacy_confirm_contexts_for_deletion"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolDataprivacyConfirmContextsForDeletionRequest == nil {
		return localVarReturnValue, nil, reportError("toolDataprivacyConfirmContextsForDeletionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolDataprivacyConfirmContextsForDeletionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolDataprivacyContactDpoRequest struct {
	ctx context.Context
	ApiService *ToolDataprivacyAPIService
	toolDataprivacyContactDpoRequest *ToolDataprivacyContactDpoRequest
}

func (r ApiToolDataprivacyContactDpoRequest) ToolDataprivacyContactDpoRequest(toolDataprivacyContactDpoRequest ToolDataprivacyContactDpoRequest) ApiToolDataprivacyContactDpoRequest {
	r.toolDataprivacyContactDpoRequest = &toolDataprivacyContactDpoRequest
	return r
}

func (r ApiToolDataprivacyContactDpoRequest) Execute() (*CoreContentbankRenameContent200Response, *http.Response, error) {
	return r.ApiService.ToolDataprivacyContactDpoExecute(r)
}

/*
ToolDataprivacyContactDpo Contact the site Data Protection Officer(s)

Contact the site Data Protection Officer(s)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolDataprivacyContactDpoRequest
*/
func (a *ToolDataprivacyAPIService) ToolDataprivacyContactDpo(ctx context.Context) ApiToolDataprivacyContactDpoRequest {
	return ApiToolDataprivacyContactDpoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreContentbankRenameContent200Response
func (a *ToolDataprivacyAPIService) ToolDataprivacyContactDpoExecute(r ApiToolDataprivacyContactDpoRequest) (*CoreContentbankRenameContent200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreContentbankRenameContent200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolDataprivacyAPIService.ToolDataprivacyContactDpo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_dataprivacy_contact_dpo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolDataprivacyContactDpoRequest == nil {
		return localVarReturnValue, nil, reportError("toolDataprivacyContactDpoRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolDataprivacyContactDpoRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolDataprivacyCreateCategoryFormRequest struct {
	ctx context.Context
	ApiService *ToolDataprivacyAPIService
	toolDataprivacyCreateCategoryFormRequest *ToolDataprivacyCreateCategoryFormRequest
}

func (r ApiToolDataprivacyCreateCategoryFormRequest) ToolDataprivacyCreateCategoryFormRequest(toolDataprivacyCreateCategoryFormRequest ToolDataprivacyCreateCategoryFormRequest) ApiToolDataprivacyCreateCategoryFormRequest {
	r.toolDataprivacyCreateCategoryFormRequest = &toolDataprivacyCreateCategoryFormRequest
	return r
}

func (r ApiToolDataprivacyCreateCategoryFormRequest) Execute() (*ToolDataprivacyCreateCategoryForm200Response, *http.Response, error) {
	return r.ApiService.ToolDataprivacyCreateCategoryFormExecute(r)
}

/*
ToolDataprivacyCreateCategoryForm Adds a data category

Adds a data category

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolDataprivacyCreateCategoryFormRequest
*/
func (a *ToolDataprivacyAPIService) ToolDataprivacyCreateCategoryForm(ctx context.Context) ApiToolDataprivacyCreateCategoryFormRequest {
	return ApiToolDataprivacyCreateCategoryFormRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolDataprivacyCreateCategoryForm200Response
func (a *ToolDataprivacyAPIService) ToolDataprivacyCreateCategoryFormExecute(r ApiToolDataprivacyCreateCategoryFormRequest) (*ToolDataprivacyCreateCategoryForm200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolDataprivacyCreateCategoryForm200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolDataprivacyAPIService.ToolDataprivacyCreateCategoryForm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_dataprivacy_create_category_form"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolDataprivacyCreateCategoryFormRequest == nil {
		return localVarReturnValue, nil, reportError("toolDataprivacyCreateCategoryFormRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolDataprivacyCreateCategoryFormRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolDataprivacyCreatePurposeFormRequest struct {
	ctx context.Context
	ApiService *ToolDataprivacyAPIService
	toolDataprivacyCreatePurposeFormRequest *ToolDataprivacyCreatePurposeFormRequest
}

func (r ApiToolDataprivacyCreatePurposeFormRequest) ToolDataprivacyCreatePurposeFormRequest(toolDataprivacyCreatePurposeFormRequest ToolDataprivacyCreatePurposeFormRequest) ApiToolDataprivacyCreatePurposeFormRequest {
	r.toolDataprivacyCreatePurposeFormRequest = &toolDataprivacyCreatePurposeFormRequest
	return r
}

func (r ApiToolDataprivacyCreatePurposeFormRequest) Execute() (*ToolDataprivacyCreatePurposeForm200Response, *http.Response, error) {
	return r.ApiService.ToolDataprivacyCreatePurposeFormExecute(r)
}

/*
ToolDataprivacyCreatePurposeForm Adds a data purpose

Adds a data purpose

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolDataprivacyCreatePurposeFormRequest
*/
func (a *ToolDataprivacyAPIService) ToolDataprivacyCreatePurposeForm(ctx context.Context) ApiToolDataprivacyCreatePurposeFormRequest {
	return ApiToolDataprivacyCreatePurposeFormRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolDataprivacyCreatePurposeForm200Response
func (a *ToolDataprivacyAPIService) ToolDataprivacyCreatePurposeFormExecute(r ApiToolDataprivacyCreatePurposeFormRequest) (*ToolDataprivacyCreatePurposeForm200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolDataprivacyCreatePurposeForm200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolDataprivacyAPIService.ToolDataprivacyCreatePurposeForm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_dataprivacy_create_purpose_form"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolDataprivacyCreatePurposeFormRequest == nil {
		return localVarReturnValue, nil, reportError("toolDataprivacyCreatePurposeFormRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolDataprivacyCreatePurposeFormRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolDataprivacyDeleteCategoryRequest struct {
	ctx context.Context
	ApiService *ToolDataprivacyAPIService
	toolDataprivacyDeleteCategoryRequest *ToolDataprivacyDeleteCategoryRequest
}

func (r ApiToolDataprivacyDeleteCategoryRequest) ToolDataprivacyDeleteCategoryRequest(toolDataprivacyDeleteCategoryRequest ToolDataprivacyDeleteCategoryRequest) ApiToolDataprivacyDeleteCategoryRequest {
	r.toolDataprivacyDeleteCategoryRequest = &toolDataprivacyDeleteCategoryRequest
	return r
}

func (r ApiToolDataprivacyDeleteCategoryRequest) Execute() (*CoreContentbankRenameContent200Response, *http.Response, error) {
	return r.ApiService.ToolDataprivacyDeleteCategoryExecute(r)
}

/*
ToolDataprivacyDeleteCategory Deletes an existing data category

Deletes an existing data category

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolDataprivacyDeleteCategoryRequest
*/
func (a *ToolDataprivacyAPIService) ToolDataprivacyDeleteCategory(ctx context.Context) ApiToolDataprivacyDeleteCategoryRequest {
	return ApiToolDataprivacyDeleteCategoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreContentbankRenameContent200Response
func (a *ToolDataprivacyAPIService) ToolDataprivacyDeleteCategoryExecute(r ApiToolDataprivacyDeleteCategoryRequest) (*CoreContentbankRenameContent200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreContentbankRenameContent200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolDataprivacyAPIService.ToolDataprivacyDeleteCategory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_dataprivacy_delete_category"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolDataprivacyDeleteCategoryRequest == nil {
		return localVarReturnValue, nil, reportError("toolDataprivacyDeleteCategoryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolDataprivacyDeleteCategoryRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolDataprivacyDeletePurposeRequest struct {
	ctx context.Context
	ApiService *ToolDataprivacyAPIService
	toolDataprivacyDeletePurposeRequest *ToolDataprivacyDeletePurposeRequest
}

func (r ApiToolDataprivacyDeletePurposeRequest) ToolDataprivacyDeletePurposeRequest(toolDataprivacyDeletePurposeRequest ToolDataprivacyDeletePurposeRequest) ApiToolDataprivacyDeletePurposeRequest {
	r.toolDataprivacyDeletePurposeRequest = &toolDataprivacyDeletePurposeRequest
	return r
}

func (r ApiToolDataprivacyDeletePurposeRequest) Execute() (*CoreContentbankRenameContent200Response, *http.Response, error) {
	return r.ApiService.ToolDataprivacyDeletePurposeExecute(r)
}

/*
ToolDataprivacyDeletePurpose Deletes an existing data purpose

Deletes an existing data purpose

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolDataprivacyDeletePurposeRequest
*/
func (a *ToolDataprivacyAPIService) ToolDataprivacyDeletePurpose(ctx context.Context) ApiToolDataprivacyDeletePurposeRequest {
	return ApiToolDataprivacyDeletePurposeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreContentbankRenameContent200Response
func (a *ToolDataprivacyAPIService) ToolDataprivacyDeletePurposeExecute(r ApiToolDataprivacyDeletePurposeRequest) (*CoreContentbankRenameContent200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreContentbankRenameContent200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolDataprivacyAPIService.ToolDataprivacyDeletePurpose")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_dataprivacy_delete_purpose"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolDataprivacyDeletePurposeRequest == nil {
		return localVarReturnValue, nil, reportError("toolDataprivacyDeletePurposeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolDataprivacyDeletePurposeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolDataprivacyDenyDataRequestRequest struct {
	ctx context.Context
	ApiService *ToolDataprivacyAPIService
	toolDataprivacyCancelDataRequestRequest *ToolDataprivacyCancelDataRequestRequest
}

func (r ApiToolDataprivacyDenyDataRequestRequest) ToolDataprivacyCancelDataRequestRequest(toolDataprivacyCancelDataRequestRequest ToolDataprivacyCancelDataRequestRequest) ApiToolDataprivacyDenyDataRequestRequest {
	r.toolDataprivacyCancelDataRequestRequest = &toolDataprivacyCancelDataRequestRequest
	return r
}

func (r ApiToolDataprivacyDenyDataRequestRequest) Execute() (*CoreContentbankRenameContent200Response, *http.Response, error) {
	return r.ApiService.ToolDataprivacyDenyDataRequestExecute(r)
}

/*
ToolDataprivacyDenyDataRequest Deny a data request

Deny a data request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolDataprivacyDenyDataRequestRequest
*/
func (a *ToolDataprivacyAPIService) ToolDataprivacyDenyDataRequest(ctx context.Context) ApiToolDataprivacyDenyDataRequestRequest {
	return ApiToolDataprivacyDenyDataRequestRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreContentbankRenameContent200Response
func (a *ToolDataprivacyAPIService) ToolDataprivacyDenyDataRequestExecute(r ApiToolDataprivacyDenyDataRequestRequest) (*CoreContentbankRenameContent200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreContentbankRenameContent200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolDataprivacyAPIService.ToolDataprivacyDenyDataRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_dataprivacy_deny_data_request"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolDataprivacyCancelDataRequestRequest == nil {
		return localVarReturnValue, nil, reportError("toolDataprivacyCancelDataRequestRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolDataprivacyCancelDataRequestRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolDataprivacyGetActivityOptionsRequest struct {
	ctx context.Context
	ApiService *ToolDataprivacyAPIService
	toolDataprivacyGetActivityOptionsRequest *ToolDataprivacyGetActivityOptionsRequest
}

func (r ApiToolDataprivacyGetActivityOptionsRequest) ToolDataprivacyGetActivityOptionsRequest(toolDataprivacyGetActivityOptionsRequest ToolDataprivacyGetActivityOptionsRequest) ApiToolDataprivacyGetActivityOptionsRequest {
	r.toolDataprivacyGetActivityOptionsRequest = &toolDataprivacyGetActivityOptionsRequest
	return r
}

func (r ApiToolDataprivacyGetActivityOptionsRequest) Execute() (*ToolDataprivacyGetActivityOptions200Response, *http.Response, error) {
	return r.ApiService.ToolDataprivacyGetActivityOptionsExecute(r)
}

/*
ToolDataprivacyGetActivityOptions Fetches a list of activity options

Fetches a list of activity options

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolDataprivacyGetActivityOptionsRequest
*/
func (a *ToolDataprivacyAPIService) ToolDataprivacyGetActivityOptions(ctx context.Context) ApiToolDataprivacyGetActivityOptionsRequest {
	return ApiToolDataprivacyGetActivityOptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolDataprivacyGetActivityOptions200Response
func (a *ToolDataprivacyAPIService) ToolDataprivacyGetActivityOptionsExecute(r ApiToolDataprivacyGetActivityOptionsRequest) (*ToolDataprivacyGetActivityOptions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolDataprivacyGetActivityOptions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolDataprivacyAPIService.ToolDataprivacyGetActivityOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_dataprivacy_get_activity_options"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolDataprivacyGetActivityOptionsRequest == nil {
		return localVarReturnValue, nil, reportError("toolDataprivacyGetActivityOptionsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolDataprivacyGetActivityOptionsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolDataprivacyGetCategoryOptionsRequest struct {
	ctx context.Context
	ApiService *ToolDataprivacyAPIService
	toolDataprivacyGetCategoryOptionsRequest *ToolDataprivacyGetCategoryOptionsRequest
}

func (r ApiToolDataprivacyGetCategoryOptionsRequest) ToolDataprivacyGetCategoryOptionsRequest(toolDataprivacyGetCategoryOptionsRequest ToolDataprivacyGetCategoryOptionsRequest) ApiToolDataprivacyGetCategoryOptionsRequest {
	r.toolDataprivacyGetCategoryOptionsRequest = &toolDataprivacyGetCategoryOptionsRequest
	return r
}

func (r ApiToolDataprivacyGetCategoryOptionsRequest) Execute() (*ToolDataprivacyGetCategoryOptions200Response, *http.Response, error) {
	return r.ApiService.ToolDataprivacyGetCategoryOptionsExecute(r)
}

/*
ToolDataprivacyGetCategoryOptions Fetches a list of data category options

Fetches a list of data category options

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolDataprivacyGetCategoryOptionsRequest
*/
func (a *ToolDataprivacyAPIService) ToolDataprivacyGetCategoryOptions(ctx context.Context) ApiToolDataprivacyGetCategoryOptionsRequest {
	return ApiToolDataprivacyGetCategoryOptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolDataprivacyGetCategoryOptions200Response
func (a *ToolDataprivacyAPIService) ToolDataprivacyGetCategoryOptionsExecute(r ApiToolDataprivacyGetCategoryOptionsRequest) (*ToolDataprivacyGetCategoryOptions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolDataprivacyGetCategoryOptions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolDataprivacyAPIService.ToolDataprivacyGetCategoryOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_dataprivacy_get_category_options"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolDataprivacyGetCategoryOptionsRequest == nil {
		return localVarReturnValue, nil, reportError("toolDataprivacyGetCategoryOptionsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolDataprivacyGetCategoryOptionsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolDataprivacyGetDataRequestRequest struct {
	ctx context.Context
	ApiService *ToolDataprivacyAPIService
	toolDataprivacyCancelDataRequestRequest *ToolDataprivacyCancelDataRequestRequest
}

func (r ApiToolDataprivacyGetDataRequestRequest) ToolDataprivacyCancelDataRequestRequest(toolDataprivacyCancelDataRequestRequest ToolDataprivacyCancelDataRequestRequest) ApiToolDataprivacyGetDataRequestRequest {
	r.toolDataprivacyCancelDataRequestRequest = &toolDataprivacyCancelDataRequestRequest
	return r
}

func (r ApiToolDataprivacyGetDataRequestRequest) Execute() (*ToolDataprivacyGetDataRequest200Response, *http.Response, error) {
	return r.ApiService.ToolDataprivacyGetDataRequestExecute(r)
}

/*
ToolDataprivacyGetDataRequest Fetch the details of a user's data request

Fetch the details of a user's data request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolDataprivacyGetDataRequestRequest
*/
func (a *ToolDataprivacyAPIService) ToolDataprivacyGetDataRequest(ctx context.Context) ApiToolDataprivacyGetDataRequestRequest {
	return ApiToolDataprivacyGetDataRequestRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolDataprivacyGetDataRequest200Response
func (a *ToolDataprivacyAPIService) ToolDataprivacyGetDataRequestExecute(r ApiToolDataprivacyGetDataRequestRequest) (*ToolDataprivacyGetDataRequest200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolDataprivacyGetDataRequest200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolDataprivacyAPIService.ToolDataprivacyGetDataRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_dataprivacy_get_data_request"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolDataprivacyCancelDataRequestRequest == nil {
		return localVarReturnValue, nil, reportError("toolDataprivacyCancelDataRequestRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolDataprivacyCancelDataRequestRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolDataprivacyGetPurposeOptionsRequest struct {
	ctx context.Context
	ApiService *ToolDataprivacyAPIService
	toolDataprivacyGetCategoryOptionsRequest *ToolDataprivacyGetCategoryOptionsRequest
}

func (r ApiToolDataprivacyGetPurposeOptionsRequest) ToolDataprivacyGetCategoryOptionsRequest(toolDataprivacyGetCategoryOptionsRequest ToolDataprivacyGetCategoryOptionsRequest) ApiToolDataprivacyGetPurposeOptionsRequest {
	r.toolDataprivacyGetCategoryOptionsRequest = &toolDataprivacyGetCategoryOptionsRequest
	return r
}

func (r ApiToolDataprivacyGetPurposeOptionsRequest) Execute() (*ToolDataprivacyGetPurposeOptions200Response, *http.Response, error) {
	return r.ApiService.ToolDataprivacyGetPurposeOptionsExecute(r)
}

/*
ToolDataprivacyGetPurposeOptions Fetches a list of data storage purpose options

Fetches a list of data storage purpose options

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolDataprivacyGetPurposeOptionsRequest
*/
func (a *ToolDataprivacyAPIService) ToolDataprivacyGetPurposeOptions(ctx context.Context) ApiToolDataprivacyGetPurposeOptionsRequest {
	return ApiToolDataprivacyGetPurposeOptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolDataprivacyGetPurposeOptions200Response
func (a *ToolDataprivacyAPIService) ToolDataprivacyGetPurposeOptionsExecute(r ApiToolDataprivacyGetPurposeOptionsRequest) (*ToolDataprivacyGetPurposeOptions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolDataprivacyGetPurposeOptions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolDataprivacyAPIService.ToolDataprivacyGetPurposeOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_dataprivacy_get_purpose_options"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolDataprivacyGetCategoryOptionsRequest == nil {
		return localVarReturnValue, nil, reportError("toolDataprivacyGetCategoryOptionsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolDataprivacyGetCategoryOptionsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolDataprivacyGetUsersRequest struct {
	ctx context.Context
	ApiService *ToolDataprivacyAPIService
	toolDataprivacyGetUsersRequest *ToolDataprivacyGetUsersRequest
}

func (r ApiToolDataprivacyGetUsersRequest) ToolDataprivacyGetUsersRequest(toolDataprivacyGetUsersRequest ToolDataprivacyGetUsersRequest) ApiToolDataprivacyGetUsersRequest {
	r.toolDataprivacyGetUsersRequest = &toolDataprivacyGetUsersRequest
	return r
}

func (r ApiToolDataprivacyGetUsersRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ToolDataprivacyGetUsersExecute(r)
}

/*
ToolDataprivacyGetUsers Fetches a list of users

Fetches a list of users

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolDataprivacyGetUsersRequest
*/
func (a *ToolDataprivacyAPIService) ToolDataprivacyGetUsers(ctx context.Context) ApiToolDataprivacyGetUsersRequest {
	return ApiToolDataprivacyGetUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ToolDataprivacyAPIService) ToolDataprivacyGetUsersExecute(r ApiToolDataprivacyGetUsersRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolDataprivacyAPIService.ToolDataprivacyGetUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_dataprivacy_get_users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolDataprivacyGetUsersRequest == nil {
		return localVarReturnValue, nil, reportError("toolDataprivacyGetUsersRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolDataprivacyGetUsersRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolDataprivacyMarkCompleteRequest struct {
	ctx context.Context
	ApiService *ToolDataprivacyAPIService
	toolDataprivacyCancelDataRequestRequest *ToolDataprivacyCancelDataRequestRequest
}

func (r ApiToolDataprivacyMarkCompleteRequest) ToolDataprivacyCancelDataRequestRequest(toolDataprivacyCancelDataRequestRequest ToolDataprivacyCancelDataRequestRequest) ApiToolDataprivacyMarkCompleteRequest {
	r.toolDataprivacyCancelDataRequestRequest = &toolDataprivacyCancelDataRequestRequest
	return r
}

func (r ApiToolDataprivacyMarkCompleteRequest) Execute() (*CoreContentbankRenameContent200Response, *http.Response, error) {
	return r.ApiService.ToolDataprivacyMarkCompleteExecute(r)
}

/*
ToolDataprivacyMarkComplete Mark a user's general enquiry as complete

Mark a user's general enquiry as complete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolDataprivacyMarkCompleteRequest
*/
func (a *ToolDataprivacyAPIService) ToolDataprivacyMarkComplete(ctx context.Context) ApiToolDataprivacyMarkCompleteRequest {
	return ApiToolDataprivacyMarkCompleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreContentbankRenameContent200Response
func (a *ToolDataprivacyAPIService) ToolDataprivacyMarkCompleteExecute(r ApiToolDataprivacyMarkCompleteRequest) (*CoreContentbankRenameContent200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreContentbankRenameContent200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolDataprivacyAPIService.ToolDataprivacyMarkComplete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_dataprivacy_mark_complete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolDataprivacyCancelDataRequestRequest == nil {
		return localVarReturnValue, nil, reportError("toolDataprivacyCancelDataRequestRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolDataprivacyCancelDataRequestRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolDataprivacySetContextDefaultsRequest struct {
	ctx context.Context
	ApiService *ToolDataprivacyAPIService
	toolDataprivacySetContextDefaultsRequest *ToolDataprivacySetContextDefaultsRequest
}

func (r ApiToolDataprivacySetContextDefaultsRequest) ToolDataprivacySetContextDefaultsRequest(toolDataprivacySetContextDefaultsRequest ToolDataprivacySetContextDefaultsRequest) ApiToolDataprivacySetContextDefaultsRequest {
	r.toolDataprivacySetContextDefaultsRequest = &toolDataprivacySetContextDefaultsRequest
	return r
}

func (r ApiToolDataprivacySetContextDefaultsRequest) Execute() (*ToolDataprivacySetContextDefaults200Response, *http.Response, error) {
	return r.ApiService.ToolDataprivacySetContextDefaultsExecute(r)
}

/*
ToolDataprivacySetContextDefaults Updates the default category and purpose for a given context level (and optionally, a plugin)

Updates the default category and purpose for a given context level (and optionally, a plugin)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolDataprivacySetContextDefaultsRequest
*/
func (a *ToolDataprivacyAPIService) ToolDataprivacySetContextDefaults(ctx context.Context) ApiToolDataprivacySetContextDefaultsRequest {
	return ApiToolDataprivacySetContextDefaultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolDataprivacySetContextDefaults200Response
func (a *ToolDataprivacyAPIService) ToolDataprivacySetContextDefaultsExecute(r ApiToolDataprivacySetContextDefaultsRequest) (*ToolDataprivacySetContextDefaults200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolDataprivacySetContextDefaults200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolDataprivacyAPIService.ToolDataprivacySetContextDefaults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_dataprivacy_set_context_defaults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolDataprivacySetContextDefaultsRequest == nil {
		return localVarReturnValue, nil, reportError("toolDataprivacySetContextDefaultsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolDataprivacySetContextDefaultsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolDataprivacySetContextFormRequest struct {
	ctx context.Context
	ApiService *ToolDataprivacyAPIService
	toolDataprivacySetContextFormRequest *ToolDataprivacySetContextFormRequest
}

func (r ApiToolDataprivacySetContextFormRequest) ToolDataprivacySetContextFormRequest(toolDataprivacySetContextFormRequest ToolDataprivacySetContextFormRequest) ApiToolDataprivacySetContextFormRequest {
	r.toolDataprivacySetContextFormRequest = &toolDataprivacySetContextFormRequest
	return r
}

func (r ApiToolDataprivacySetContextFormRequest) Execute() (*ToolDataprivacySetContextForm200Response, *http.Response, error) {
	return r.ApiService.ToolDataprivacySetContextFormExecute(r)
}

/*
ToolDataprivacySetContextForm Sets purpose and category for a specific context

Sets purpose and category for a specific context

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolDataprivacySetContextFormRequest
*/
func (a *ToolDataprivacyAPIService) ToolDataprivacySetContextForm(ctx context.Context) ApiToolDataprivacySetContextFormRequest {
	return ApiToolDataprivacySetContextFormRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolDataprivacySetContextForm200Response
func (a *ToolDataprivacyAPIService) ToolDataprivacySetContextFormExecute(r ApiToolDataprivacySetContextFormRequest) (*ToolDataprivacySetContextForm200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolDataprivacySetContextForm200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolDataprivacyAPIService.ToolDataprivacySetContextForm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_dataprivacy_set_context_form"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolDataprivacySetContextFormRequest == nil {
		return localVarReturnValue, nil, reportError("toolDataprivacySetContextFormRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolDataprivacySetContextFormRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolDataprivacySetContextlevelFormRequest struct {
	ctx context.Context
	ApiService *ToolDataprivacyAPIService
	toolDataprivacySetContextlevelFormRequest *ToolDataprivacySetContextlevelFormRequest
}

func (r ApiToolDataprivacySetContextlevelFormRequest) ToolDataprivacySetContextlevelFormRequest(toolDataprivacySetContextlevelFormRequest ToolDataprivacySetContextlevelFormRequest) ApiToolDataprivacySetContextlevelFormRequest {
	r.toolDataprivacySetContextlevelFormRequest = &toolDataprivacySetContextlevelFormRequest
	return r
}

func (r ApiToolDataprivacySetContextlevelFormRequest) Execute() (*ToolDataprivacySetContextlevelForm200Response, *http.Response, error) {
	return r.ApiService.ToolDataprivacySetContextlevelFormExecute(r)
}

/*
ToolDataprivacySetContextlevelForm Sets purpose and category across a context level

Sets purpose and category across a context level

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolDataprivacySetContextlevelFormRequest
*/
func (a *ToolDataprivacyAPIService) ToolDataprivacySetContextlevelForm(ctx context.Context) ApiToolDataprivacySetContextlevelFormRequest {
	return ApiToolDataprivacySetContextlevelFormRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolDataprivacySetContextlevelForm200Response
func (a *ToolDataprivacyAPIService) ToolDataprivacySetContextlevelFormExecute(r ApiToolDataprivacySetContextlevelFormRequest) (*ToolDataprivacySetContextlevelForm200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolDataprivacySetContextlevelForm200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolDataprivacyAPIService.ToolDataprivacySetContextlevelForm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_dataprivacy_set_contextlevel_form"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolDataprivacySetContextlevelFormRequest == nil {
		return localVarReturnValue, nil, reportError("toolDataprivacySetContextlevelFormRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolDataprivacySetContextlevelFormRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolDataprivacySubmitSelectedCoursesFormRequest struct {
	ctx context.Context
	ApiService *ToolDataprivacyAPIService
	toolDataprivacySubmitSelectedCoursesFormRequest *ToolDataprivacySubmitSelectedCoursesFormRequest
}

func (r ApiToolDataprivacySubmitSelectedCoursesFormRequest) ToolDataprivacySubmitSelectedCoursesFormRequest(toolDataprivacySubmitSelectedCoursesFormRequest ToolDataprivacySubmitSelectedCoursesFormRequest) ApiToolDataprivacySubmitSelectedCoursesFormRequest {
	r.toolDataprivacySubmitSelectedCoursesFormRequest = &toolDataprivacySubmitSelectedCoursesFormRequest
	return r
}

func (r ApiToolDataprivacySubmitSelectedCoursesFormRequest) Execute() (*CoreContentbankRenameContent200Response, *http.Response, error) {
	return r.ApiService.ToolDataprivacySubmitSelectedCoursesFormExecute(r)
}

/*
ToolDataprivacySubmitSelectedCoursesForm Save list of selected courses for export

Save list of selected courses for export

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolDataprivacySubmitSelectedCoursesFormRequest
*/
func (a *ToolDataprivacyAPIService) ToolDataprivacySubmitSelectedCoursesForm(ctx context.Context) ApiToolDataprivacySubmitSelectedCoursesFormRequest {
	return ApiToolDataprivacySubmitSelectedCoursesFormRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreContentbankRenameContent200Response
func (a *ToolDataprivacyAPIService) ToolDataprivacySubmitSelectedCoursesFormExecute(r ApiToolDataprivacySubmitSelectedCoursesFormRequest) (*CoreContentbankRenameContent200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreContentbankRenameContent200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolDataprivacyAPIService.ToolDataprivacySubmitSelectedCoursesForm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_dataprivacy_submit_selected_courses_form"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolDataprivacySubmitSelectedCoursesFormRequest == nil {
		return localVarReturnValue, nil, reportError("toolDataprivacySubmitSelectedCoursesFormRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolDataprivacySubmitSelectedCoursesFormRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolDataprivacyTreeExtraBranchesRequest struct {
	ctx context.Context
	ApiService *ToolDataprivacyAPIService
	toolDataprivacyTreeExtraBranchesRequest *ToolDataprivacyTreeExtraBranchesRequest
}

func (r ApiToolDataprivacyTreeExtraBranchesRequest) ToolDataprivacyTreeExtraBranchesRequest(toolDataprivacyTreeExtraBranchesRequest ToolDataprivacyTreeExtraBranchesRequest) ApiToolDataprivacyTreeExtraBranchesRequest {
	r.toolDataprivacyTreeExtraBranchesRequest = &toolDataprivacyTreeExtraBranchesRequest
	return r
}

func (r ApiToolDataprivacyTreeExtraBranchesRequest) Execute() (*ToolDataprivacyTreeExtraBranches200Response, *http.Response, error) {
	return r.ApiService.ToolDataprivacyTreeExtraBranchesExecute(r)
}

/*
ToolDataprivacyTreeExtraBranches Return branches for the context tree

Return branches for the context tree

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolDataprivacyTreeExtraBranchesRequest
*/
func (a *ToolDataprivacyAPIService) ToolDataprivacyTreeExtraBranches(ctx context.Context) ApiToolDataprivacyTreeExtraBranchesRequest {
	return ApiToolDataprivacyTreeExtraBranchesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolDataprivacyTreeExtraBranches200Response
func (a *ToolDataprivacyAPIService) ToolDataprivacyTreeExtraBranchesExecute(r ApiToolDataprivacyTreeExtraBranchesRequest) (*ToolDataprivacyTreeExtraBranches200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolDataprivacyTreeExtraBranches200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolDataprivacyAPIService.ToolDataprivacyTreeExtraBranches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_dataprivacy_tree_extra_branches"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolDataprivacyTreeExtraBranchesRequest == nil {
		return localVarReturnValue, nil, reportError("toolDataprivacyTreeExtraBranchesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolDataprivacyTreeExtraBranchesRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
