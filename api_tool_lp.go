/*
Moodle Webservice API

Auto-generated OpenAPI spec for Moodle's Webservice API. Requires installation of the Catalyst RESTful API plugin: https://github.com/catalyst/moodle-webservice_restful.

API version: 4.3.4
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package moodleclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// ToolLpAPIService ToolLpAPI service
type ToolLpAPIService service

type ApiToolLpDataForCompetenciesManagePageRequest struct {
	ctx context.Context
	ApiService *ToolLpAPIService
	toolLpDataForCompetenciesManagePageRequest *ToolLpDataForCompetenciesManagePageRequest
}

func (r ApiToolLpDataForCompetenciesManagePageRequest) ToolLpDataForCompetenciesManagePageRequest(toolLpDataForCompetenciesManagePageRequest ToolLpDataForCompetenciesManagePageRequest) ApiToolLpDataForCompetenciesManagePageRequest {
	r.toolLpDataForCompetenciesManagePageRequest = &toolLpDataForCompetenciesManagePageRequest
	return r
}

func (r ApiToolLpDataForCompetenciesManagePageRequest) Execute() (*ToolLpDataForCompetenciesManagePage200Response, *http.Response, error) {
	return r.ApiService.ToolLpDataForCompetenciesManagePageExecute(r)
}

/*
ToolLpDataForCompetenciesManagePage Load the data for the competencies manage page template

Load the data for the competencies manage page template

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolLpDataForCompetenciesManagePageRequest
*/
func (a *ToolLpAPIService) ToolLpDataForCompetenciesManagePage(ctx context.Context) ApiToolLpDataForCompetenciesManagePageRequest {
	return ApiToolLpDataForCompetenciesManagePageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolLpDataForCompetenciesManagePage200Response
func (a *ToolLpAPIService) ToolLpDataForCompetenciesManagePageExecute(r ApiToolLpDataForCompetenciesManagePageRequest) (*ToolLpDataForCompetenciesManagePage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolLpDataForCompetenciesManagePage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolLpAPIService.ToolLpDataForCompetenciesManagePage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_lp_data_for_competencies_manage_page"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolLpDataForCompetenciesManagePageRequest == nil {
		return localVarReturnValue, nil, reportError("toolLpDataForCompetenciesManagePageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolLpDataForCompetenciesManagePageRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolLpDataForCompetencyFrameworksManagePageRequest struct {
	ctx context.Context
	ApiService *ToolLpAPIService
	toolLpDataForCompetencyFrameworksManagePageRequest *ToolLpDataForCompetencyFrameworksManagePageRequest
}

func (r ApiToolLpDataForCompetencyFrameworksManagePageRequest) ToolLpDataForCompetencyFrameworksManagePageRequest(toolLpDataForCompetencyFrameworksManagePageRequest ToolLpDataForCompetencyFrameworksManagePageRequest) ApiToolLpDataForCompetencyFrameworksManagePageRequest {
	r.toolLpDataForCompetencyFrameworksManagePageRequest = &toolLpDataForCompetencyFrameworksManagePageRequest
	return r
}

func (r ApiToolLpDataForCompetencyFrameworksManagePageRequest) Execute() (*ToolLpDataForCompetencyFrameworksManagePage200Response, *http.Response, error) {
	return r.ApiService.ToolLpDataForCompetencyFrameworksManagePageExecute(r)
}

/*
ToolLpDataForCompetencyFrameworksManagePage Load the data for the competency frameworks manage page template

Load the data for the competency frameworks manage page template

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolLpDataForCompetencyFrameworksManagePageRequest
*/
func (a *ToolLpAPIService) ToolLpDataForCompetencyFrameworksManagePage(ctx context.Context) ApiToolLpDataForCompetencyFrameworksManagePageRequest {
	return ApiToolLpDataForCompetencyFrameworksManagePageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolLpDataForCompetencyFrameworksManagePage200Response
func (a *ToolLpAPIService) ToolLpDataForCompetencyFrameworksManagePageExecute(r ApiToolLpDataForCompetencyFrameworksManagePageRequest) (*ToolLpDataForCompetencyFrameworksManagePage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolLpDataForCompetencyFrameworksManagePage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolLpAPIService.ToolLpDataForCompetencyFrameworksManagePage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_lp_data_for_competency_frameworks_manage_page"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolLpDataForCompetencyFrameworksManagePageRequest == nil {
		return localVarReturnValue, nil, reportError("toolLpDataForCompetencyFrameworksManagePageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolLpDataForCompetencyFrameworksManagePageRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolLpDataForCompetencySummaryRequest struct {
	ctx context.Context
	ApiService *ToolLpAPIService
	toolLpDataForCompetencySummaryRequest *ToolLpDataForCompetencySummaryRequest
}

func (r ApiToolLpDataForCompetencySummaryRequest) ToolLpDataForCompetencySummaryRequest(toolLpDataForCompetencySummaryRequest ToolLpDataForCompetencySummaryRequest) ApiToolLpDataForCompetencySummaryRequest {
	r.toolLpDataForCompetencySummaryRequest = &toolLpDataForCompetencySummaryRequest
	return r
}

func (r ApiToolLpDataForCompetencySummaryRequest) Execute() (*ToolLpDataForCompetencySummary200Response, *http.Response, error) {
	return r.ApiService.ToolLpDataForCompetencySummaryExecute(r)
}

/*
ToolLpDataForCompetencySummary Load competency data for summary template.

Load competency data for summary template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolLpDataForCompetencySummaryRequest
*/
func (a *ToolLpAPIService) ToolLpDataForCompetencySummary(ctx context.Context) ApiToolLpDataForCompetencySummaryRequest {
	return ApiToolLpDataForCompetencySummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolLpDataForCompetencySummary200Response
func (a *ToolLpAPIService) ToolLpDataForCompetencySummaryExecute(r ApiToolLpDataForCompetencySummaryRequest) (*ToolLpDataForCompetencySummary200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolLpDataForCompetencySummary200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolLpAPIService.ToolLpDataForCompetencySummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_lp_data_for_competency_summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolLpDataForCompetencySummaryRequest == nil {
		return localVarReturnValue, nil, reportError("toolLpDataForCompetencySummaryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolLpDataForCompetencySummaryRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolLpDataForCourseCompetenciesPageRequest struct {
	ctx context.Context
	ApiService *ToolLpAPIService
	toolLpDataForCourseCompetenciesPageRequest *ToolLpDataForCourseCompetenciesPageRequest
}

func (r ApiToolLpDataForCourseCompetenciesPageRequest) ToolLpDataForCourseCompetenciesPageRequest(toolLpDataForCourseCompetenciesPageRequest ToolLpDataForCourseCompetenciesPageRequest) ApiToolLpDataForCourseCompetenciesPageRequest {
	r.toolLpDataForCourseCompetenciesPageRequest = &toolLpDataForCourseCompetenciesPageRequest
	return r
}

func (r ApiToolLpDataForCourseCompetenciesPageRequest) Execute() (*ToolLpDataForCourseCompetenciesPage200Response, *http.Response, error) {
	return r.ApiService.ToolLpDataForCourseCompetenciesPageExecute(r)
}

/*
ToolLpDataForCourseCompetenciesPage Load the data for the course competencies page template.

Load the data for the course competencies page template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolLpDataForCourseCompetenciesPageRequest
*/
func (a *ToolLpAPIService) ToolLpDataForCourseCompetenciesPage(ctx context.Context) ApiToolLpDataForCourseCompetenciesPageRequest {
	return ApiToolLpDataForCourseCompetenciesPageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolLpDataForCourseCompetenciesPage200Response
func (a *ToolLpAPIService) ToolLpDataForCourseCompetenciesPageExecute(r ApiToolLpDataForCourseCompetenciesPageRequest) (*ToolLpDataForCourseCompetenciesPage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolLpDataForCourseCompetenciesPage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolLpAPIService.ToolLpDataForCourseCompetenciesPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_lp_data_for_course_competencies_page"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolLpDataForCourseCompetenciesPageRequest == nil {
		return localVarReturnValue, nil, reportError("toolLpDataForCourseCompetenciesPageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolLpDataForCourseCompetenciesPageRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolLpDataForPlanPageRequest struct {
	ctx context.Context
	ApiService *ToolLpAPIService
	coreCompetencyCompletePlanRequest *CoreCompetencyCompletePlanRequest
}

func (r ApiToolLpDataForPlanPageRequest) CoreCompetencyCompletePlanRequest(coreCompetencyCompletePlanRequest CoreCompetencyCompletePlanRequest) ApiToolLpDataForPlanPageRequest {
	r.coreCompetencyCompletePlanRequest = &coreCompetencyCompletePlanRequest
	return r
}

func (r ApiToolLpDataForPlanPageRequest) Execute() (*ToolLpDataForPlanPage200Response, *http.Response, error) {
	return r.ApiService.ToolLpDataForPlanPageExecute(r)
}

/*
ToolLpDataForPlanPage Load the data for the plan page template.

Load the data for the plan page template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolLpDataForPlanPageRequest
*/
func (a *ToolLpAPIService) ToolLpDataForPlanPage(ctx context.Context) ApiToolLpDataForPlanPageRequest {
	return ApiToolLpDataForPlanPageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolLpDataForPlanPage200Response
func (a *ToolLpAPIService) ToolLpDataForPlanPageExecute(r ApiToolLpDataForPlanPageRequest) (*ToolLpDataForPlanPage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolLpDataForPlanPage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolLpAPIService.ToolLpDataForPlanPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_lp_data_for_plan_page"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coreCompetencyCompletePlanRequest == nil {
		return localVarReturnValue, nil, reportError("coreCompetencyCompletePlanRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.coreCompetencyCompletePlanRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolLpDataForPlansPageRequest struct {
	ctx context.Context
	ApiService *ToolLpAPIService
	toolLpDataForPlansPageRequest *ToolLpDataForPlansPageRequest
}

func (r ApiToolLpDataForPlansPageRequest) ToolLpDataForPlansPageRequest(toolLpDataForPlansPageRequest ToolLpDataForPlansPageRequest) ApiToolLpDataForPlansPageRequest {
	r.toolLpDataForPlansPageRequest = &toolLpDataForPlansPageRequest
	return r
}

func (r ApiToolLpDataForPlansPageRequest) Execute() (*ToolLpDataForPlansPage200Response, *http.Response, error) {
	return r.ApiService.ToolLpDataForPlansPageExecute(r)
}

/*
ToolLpDataForPlansPage Load the data for the plans page template

Load the data for the plans page template

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolLpDataForPlansPageRequest
*/
func (a *ToolLpAPIService) ToolLpDataForPlansPage(ctx context.Context) ApiToolLpDataForPlansPageRequest {
	return ApiToolLpDataForPlansPageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolLpDataForPlansPage200Response
func (a *ToolLpAPIService) ToolLpDataForPlansPageExecute(r ApiToolLpDataForPlansPageRequest) (*ToolLpDataForPlansPage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolLpDataForPlansPage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolLpAPIService.ToolLpDataForPlansPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_lp_data_for_plans_page"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolLpDataForPlansPageRequest == nil {
		return localVarReturnValue, nil, reportError("toolLpDataForPlansPageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolLpDataForPlansPageRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolLpDataForRelatedCompetenciesSectionRequest struct {
	ctx context.Context
	ApiService *ToolLpAPIService
	toolLpDataForRelatedCompetenciesSectionRequest *ToolLpDataForRelatedCompetenciesSectionRequest
}

func (r ApiToolLpDataForRelatedCompetenciesSectionRequest) ToolLpDataForRelatedCompetenciesSectionRequest(toolLpDataForRelatedCompetenciesSectionRequest ToolLpDataForRelatedCompetenciesSectionRequest) ApiToolLpDataForRelatedCompetenciesSectionRequest {
	r.toolLpDataForRelatedCompetenciesSectionRequest = &toolLpDataForRelatedCompetenciesSectionRequest
	return r
}

func (r ApiToolLpDataForRelatedCompetenciesSectionRequest) Execute() (*ToolLpDataForRelatedCompetenciesSection200Response, *http.Response, error) {
	return r.ApiService.ToolLpDataForRelatedCompetenciesSectionExecute(r)
}

/*
ToolLpDataForRelatedCompetenciesSection Load the data for the related competencies template.

Load the data for the related competencies template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolLpDataForRelatedCompetenciesSectionRequest
*/
func (a *ToolLpAPIService) ToolLpDataForRelatedCompetenciesSection(ctx context.Context) ApiToolLpDataForRelatedCompetenciesSectionRequest {
	return ApiToolLpDataForRelatedCompetenciesSectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolLpDataForRelatedCompetenciesSection200Response
func (a *ToolLpAPIService) ToolLpDataForRelatedCompetenciesSectionExecute(r ApiToolLpDataForRelatedCompetenciesSectionRequest) (*ToolLpDataForRelatedCompetenciesSection200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolLpDataForRelatedCompetenciesSection200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolLpAPIService.ToolLpDataForRelatedCompetenciesSection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_lp_data_for_related_competencies_section"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolLpDataForRelatedCompetenciesSectionRequest == nil {
		return localVarReturnValue, nil, reportError("toolLpDataForRelatedCompetenciesSectionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolLpDataForRelatedCompetenciesSectionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolLpDataForTemplateCompetenciesPageRequest struct {
	ctx context.Context
	ApiService *ToolLpAPIService
	toolLpDataForTemplateCompetenciesPageRequest *ToolLpDataForTemplateCompetenciesPageRequest
}

func (r ApiToolLpDataForTemplateCompetenciesPageRequest) ToolLpDataForTemplateCompetenciesPageRequest(toolLpDataForTemplateCompetenciesPageRequest ToolLpDataForTemplateCompetenciesPageRequest) ApiToolLpDataForTemplateCompetenciesPageRequest {
	r.toolLpDataForTemplateCompetenciesPageRequest = &toolLpDataForTemplateCompetenciesPageRequest
	return r
}

func (r ApiToolLpDataForTemplateCompetenciesPageRequest) Execute() (*ToolLpDataForTemplateCompetenciesPage200Response, *http.Response, error) {
	return r.ApiService.ToolLpDataForTemplateCompetenciesPageExecute(r)
}

/*
ToolLpDataForTemplateCompetenciesPage Load the data for the template competencies page template.

Load the data for the template competencies page template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolLpDataForTemplateCompetenciesPageRequest
*/
func (a *ToolLpAPIService) ToolLpDataForTemplateCompetenciesPage(ctx context.Context) ApiToolLpDataForTemplateCompetenciesPageRequest {
	return ApiToolLpDataForTemplateCompetenciesPageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolLpDataForTemplateCompetenciesPage200Response
func (a *ToolLpAPIService) ToolLpDataForTemplateCompetenciesPageExecute(r ApiToolLpDataForTemplateCompetenciesPageRequest) (*ToolLpDataForTemplateCompetenciesPage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolLpDataForTemplateCompetenciesPage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolLpAPIService.ToolLpDataForTemplateCompetenciesPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_lp_data_for_template_competencies_page"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolLpDataForTemplateCompetenciesPageRequest == nil {
		return localVarReturnValue, nil, reportError("toolLpDataForTemplateCompetenciesPageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolLpDataForTemplateCompetenciesPageRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolLpDataForTemplatesManagePageRequest struct {
	ctx context.Context
	ApiService *ToolLpAPIService
	toolLpDataForCompetencyFrameworksManagePageRequest *ToolLpDataForCompetencyFrameworksManagePageRequest
}

func (r ApiToolLpDataForTemplatesManagePageRequest) ToolLpDataForCompetencyFrameworksManagePageRequest(toolLpDataForCompetencyFrameworksManagePageRequest ToolLpDataForCompetencyFrameworksManagePageRequest) ApiToolLpDataForTemplatesManagePageRequest {
	r.toolLpDataForCompetencyFrameworksManagePageRequest = &toolLpDataForCompetencyFrameworksManagePageRequest
	return r
}

func (r ApiToolLpDataForTemplatesManagePageRequest) Execute() (*ToolLpDataForTemplatesManagePage200Response, *http.Response, error) {
	return r.ApiService.ToolLpDataForTemplatesManagePageExecute(r)
}

/*
ToolLpDataForTemplatesManagePage Load the data for the learning plan templates manage page template

Load the data for the learning plan templates manage page template

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolLpDataForTemplatesManagePageRequest
*/
func (a *ToolLpAPIService) ToolLpDataForTemplatesManagePage(ctx context.Context) ApiToolLpDataForTemplatesManagePageRequest {
	return ApiToolLpDataForTemplatesManagePageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolLpDataForTemplatesManagePage200Response
func (a *ToolLpAPIService) ToolLpDataForTemplatesManagePageExecute(r ApiToolLpDataForTemplatesManagePageRequest) (*ToolLpDataForTemplatesManagePage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolLpDataForTemplatesManagePage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolLpAPIService.ToolLpDataForTemplatesManagePage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_lp_data_for_templates_manage_page"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolLpDataForCompetencyFrameworksManagePageRequest == nil {
		return localVarReturnValue, nil, reportError("toolLpDataForCompetencyFrameworksManagePageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolLpDataForCompetencyFrameworksManagePageRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolLpDataForUserCompetencySummaryRequest struct {
	ctx context.Context
	ApiService *ToolLpAPIService
	toolLpDataForUserCompetencySummaryRequest *ToolLpDataForUserCompetencySummaryRequest
}

func (r ApiToolLpDataForUserCompetencySummaryRequest) ToolLpDataForUserCompetencySummaryRequest(toolLpDataForUserCompetencySummaryRequest ToolLpDataForUserCompetencySummaryRequest) ApiToolLpDataForUserCompetencySummaryRequest {
	r.toolLpDataForUserCompetencySummaryRequest = &toolLpDataForUserCompetencySummaryRequest
	return r
}

func (r ApiToolLpDataForUserCompetencySummaryRequest) Execute() (*ToolLpDataForUserCompetencySummary200Response, *http.Response, error) {
	return r.ApiService.ToolLpDataForUserCompetencySummaryExecute(r)
}

/*
ToolLpDataForUserCompetencySummary Load a summary of a user competency.

Load a summary of a user competency.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolLpDataForUserCompetencySummaryRequest
*/
func (a *ToolLpAPIService) ToolLpDataForUserCompetencySummary(ctx context.Context) ApiToolLpDataForUserCompetencySummaryRequest {
	return ApiToolLpDataForUserCompetencySummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolLpDataForUserCompetencySummary200Response
func (a *ToolLpAPIService) ToolLpDataForUserCompetencySummaryExecute(r ApiToolLpDataForUserCompetencySummaryRequest) (*ToolLpDataForUserCompetencySummary200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolLpDataForUserCompetencySummary200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolLpAPIService.ToolLpDataForUserCompetencySummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_lp_data_for_user_competency_summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolLpDataForUserCompetencySummaryRequest == nil {
		return localVarReturnValue, nil, reportError("toolLpDataForUserCompetencySummaryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolLpDataForUserCompetencySummaryRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolLpDataForUserCompetencySummaryInCourseRequest struct {
	ctx context.Context
	ApiService *ToolLpAPIService
	toolLpDataForUserCompetencySummaryInCourseRequest *ToolLpDataForUserCompetencySummaryInCourseRequest
}

func (r ApiToolLpDataForUserCompetencySummaryInCourseRequest) ToolLpDataForUserCompetencySummaryInCourseRequest(toolLpDataForUserCompetencySummaryInCourseRequest ToolLpDataForUserCompetencySummaryInCourseRequest) ApiToolLpDataForUserCompetencySummaryInCourseRequest {
	r.toolLpDataForUserCompetencySummaryInCourseRequest = &toolLpDataForUserCompetencySummaryInCourseRequest
	return r
}

func (r ApiToolLpDataForUserCompetencySummaryInCourseRequest) Execute() (*ToolLpDataForUserCompetencySummaryInCourse200Response, *http.Response, error) {
	return r.ApiService.ToolLpDataForUserCompetencySummaryInCourseExecute(r)
}

/*
ToolLpDataForUserCompetencySummaryInCourse Load a summary of a user competency.

Load a summary of a user competency.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolLpDataForUserCompetencySummaryInCourseRequest
*/
func (a *ToolLpAPIService) ToolLpDataForUserCompetencySummaryInCourse(ctx context.Context) ApiToolLpDataForUserCompetencySummaryInCourseRequest {
	return ApiToolLpDataForUserCompetencySummaryInCourseRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolLpDataForUserCompetencySummaryInCourse200Response
func (a *ToolLpAPIService) ToolLpDataForUserCompetencySummaryInCourseExecute(r ApiToolLpDataForUserCompetencySummaryInCourseRequest) (*ToolLpDataForUserCompetencySummaryInCourse200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolLpDataForUserCompetencySummaryInCourse200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolLpAPIService.ToolLpDataForUserCompetencySummaryInCourse")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_lp_data_for_user_competency_summary_in_course"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolLpDataForUserCompetencySummaryInCourseRequest == nil {
		return localVarReturnValue, nil, reportError("toolLpDataForUserCompetencySummaryInCourseRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolLpDataForUserCompetencySummaryInCourseRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolLpDataForUserCompetencySummaryInPlanRequest struct {
	ctx context.Context
	ApiService *ToolLpAPIService
	toolLpDataForUserCompetencySummaryInPlanRequest *ToolLpDataForUserCompetencySummaryInPlanRequest
}

func (r ApiToolLpDataForUserCompetencySummaryInPlanRequest) ToolLpDataForUserCompetencySummaryInPlanRequest(toolLpDataForUserCompetencySummaryInPlanRequest ToolLpDataForUserCompetencySummaryInPlanRequest) ApiToolLpDataForUserCompetencySummaryInPlanRequest {
	r.toolLpDataForUserCompetencySummaryInPlanRequest = &toolLpDataForUserCompetencySummaryInPlanRequest
	return r
}

func (r ApiToolLpDataForUserCompetencySummaryInPlanRequest) Execute() (*ToolLpDataForUserCompetencySummaryInPlan200Response, *http.Response, error) {
	return r.ApiService.ToolLpDataForUserCompetencySummaryInPlanExecute(r)
}

/*
ToolLpDataForUserCompetencySummaryInPlan Load a summary of a user competency.

Load a summary of a user competency.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolLpDataForUserCompetencySummaryInPlanRequest
*/
func (a *ToolLpAPIService) ToolLpDataForUserCompetencySummaryInPlan(ctx context.Context) ApiToolLpDataForUserCompetencySummaryInPlanRequest {
	return ApiToolLpDataForUserCompetencySummaryInPlanRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolLpDataForUserCompetencySummaryInPlan200Response
func (a *ToolLpAPIService) ToolLpDataForUserCompetencySummaryInPlanExecute(r ApiToolLpDataForUserCompetencySummaryInPlanRequest) (*ToolLpDataForUserCompetencySummaryInPlan200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolLpDataForUserCompetencySummaryInPlan200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolLpAPIService.ToolLpDataForUserCompetencySummaryInPlan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_lp_data_for_user_competency_summary_in_plan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolLpDataForUserCompetencySummaryInPlanRequest == nil {
		return localVarReturnValue, nil, reportError("toolLpDataForUserCompetencySummaryInPlanRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolLpDataForUserCompetencySummaryInPlanRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolLpDataForUserEvidenceListPageRequest struct {
	ctx context.Context
	ApiService *ToolLpAPIService
	toolLpDataForUserEvidenceListPageRequest *ToolLpDataForUserEvidenceListPageRequest
}

func (r ApiToolLpDataForUserEvidenceListPageRequest) ToolLpDataForUserEvidenceListPageRequest(toolLpDataForUserEvidenceListPageRequest ToolLpDataForUserEvidenceListPageRequest) ApiToolLpDataForUserEvidenceListPageRequest {
	r.toolLpDataForUserEvidenceListPageRequest = &toolLpDataForUserEvidenceListPageRequest
	return r
}

func (r ApiToolLpDataForUserEvidenceListPageRequest) Execute() (*ToolLpDataForUserEvidenceListPage200Response, *http.Response, error) {
	return r.ApiService.ToolLpDataForUserEvidenceListPageExecute(r)
}

/*
ToolLpDataForUserEvidenceListPage Load the data for the user evidence list page template

Load the data for the user evidence list page template

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolLpDataForUserEvidenceListPageRequest
*/
func (a *ToolLpAPIService) ToolLpDataForUserEvidenceListPage(ctx context.Context) ApiToolLpDataForUserEvidenceListPageRequest {
	return ApiToolLpDataForUserEvidenceListPageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolLpDataForUserEvidenceListPage200Response
func (a *ToolLpAPIService) ToolLpDataForUserEvidenceListPageExecute(r ApiToolLpDataForUserEvidenceListPageRequest) (*ToolLpDataForUserEvidenceListPage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolLpDataForUserEvidenceListPage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolLpAPIService.ToolLpDataForUserEvidenceListPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_lp_data_for_user_evidence_list_page"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolLpDataForUserEvidenceListPageRequest == nil {
		return localVarReturnValue, nil, reportError("toolLpDataForUserEvidenceListPageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolLpDataForUserEvidenceListPageRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolLpDataForUserEvidencePageRequest struct {
	ctx context.Context
	ApiService *ToolLpAPIService
	toolLpDataForUserEvidencePageRequest *ToolLpDataForUserEvidencePageRequest
}

func (r ApiToolLpDataForUserEvidencePageRequest) ToolLpDataForUserEvidencePageRequest(toolLpDataForUserEvidencePageRequest ToolLpDataForUserEvidencePageRequest) ApiToolLpDataForUserEvidencePageRequest {
	r.toolLpDataForUserEvidencePageRequest = &toolLpDataForUserEvidencePageRequest
	return r
}

func (r ApiToolLpDataForUserEvidencePageRequest) Execute() (*ToolLpDataForUserEvidencePage200Response, *http.Response, error) {
	return r.ApiService.ToolLpDataForUserEvidencePageExecute(r)
}

/*
ToolLpDataForUserEvidencePage Load the data for the user evidence page template

Load the data for the user evidence page template

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolLpDataForUserEvidencePageRequest
*/
func (a *ToolLpAPIService) ToolLpDataForUserEvidencePage(ctx context.Context) ApiToolLpDataForUserEvidencePageRequest {
	return ApiToolLpDataForUserEvidencePageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolLpDataForUserEvidencePage200Response
func (a *ToolLpAPIService) ToolLpDataForUserEvidencePageExecute(r ApiToolLpDataForUserEvidencePageRequest) (*ToolLpDataForUserEvidencePage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolLpDataForUserEvidencePage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolLpAPIService.ToolLpDataForUserEvidencePage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_lp_data_for_user_evidence_page"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolLpDataForUserEvidencePageRequest == nil {
		return localVarReturnValue, nil, reportError("toolLpDataForUserEvidencePageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolLpDataForUserEvidencePageRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolLpListCoursesUsingCompetencyRequest struct {
	ctx context.Context
	ApiService *ToolLpAPIService
	coreCompetencyCompetencyViewedRequest *CoreCompetencyCompetencyViewedRequest
}

func (r ApiToolLpListCoursesUsingCompetencyRequest) CoreCompetencyCompetencyViewedRequest(coreCompetencyCompetencyViewedRequest CoreCompetencyCompetencyViewedRequest) ApiToolLpListCoursesUsingCompetencyRequest {
	r.coreCompetencyCompetencyViewedRequest = &coreCompetencyCompetencyViewedRequest
	return r
}

func (r ApiToolLpListCoursesUsingCompetencyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ToolLpListCoursesUsingCompetencyExecute(r)
}

/*
ToolLpListCoursesUsingCompetency List the courses using a competency

List the courses using a competency

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolLpListCoursesUsingCompetencyRequest
*/
func (a *ToolLpAPIService) ToolLpListCoursesUsingCompetency(ctx context.Context) ApiToolLpListCoursesUsingCompetencyRequest {
	return ApiToolLpListCoursesUsingCompetencyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ToolLpAPIService) ToolLpListCoursesUsingCompetencyExecute(r ApiToolLpListCoursesUsingCompetencyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolLpAPIService.ToolLpListCoursesUsingCompetency")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_lp_list_courses_using_competency"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coreCompetencyCompetencyViewedRequest == nil {
		return localVarReturnValue, nil, reportError("coreCompetencyCompetencyViewedRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.coreCompetencyCompetencyViewedRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolLpSearchCohortsRequest struct {
	ctx context.Context
	ApiService *ToolLpAPIService
	toolLpSearchCohortsRequest *ToolLpSearchCohortsRequest
}

func (r ApiToolLpSearchCohortsRequest) ToolLpSearchCohortsRequest(toolLpSearchCohortsRequest ToolLpSearchCohortsRequest) ApiToolLpSearchCohortsRequest {
	r.toolLpSearchCohortsRequest = &toolLpSearchCohortsRequest
	return r
}

func (r ApiToolLpSearchCohortsRequest) Execute() (*ToolLpSearchCohorts200Response, *http.Response, error) {
	return r.ApiService.ToolLpSearchCohortsExecute(r)
}

/*
ToolLpSearchCohorts Search for cohorts. This method is deprecated, please call 'core_cohort_search_cohorts' instead

Search for cohorts. This method is deprecated, please call 'core_cohort_search_cohorts' instead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolLpSearchCohortsRequest
*/
func (a *ToolLpAPIService) ToolLpSearchCohorts(ctx context.Context) ApiToolLpSearchCohortsRequest {
	return ApiToolLpSearchCohortsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolLpSearchCohorts200Response
func (a *ToolLpAPIService) ToolLpSearchCohortsExecute(r ApiToolLpSearchCohortsRequest) (*ToolLpSearchCohorts200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolLpSearchCohorts200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolLpAPIService.ToolLpSearchCohorts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_lp_search_cohorts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolLpSearchCohortsRequest == nil {
		return localVarReturnValue, nil, reportError("toolLpSearchCohortsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolLpSearchCohortsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToolLpSearchUsersRequest struct {
	ctx context.Context
	ApiService *ToolLpAPIService
	toolLpSearchUsersRequest *ToolLpSearchUsersRequest
}

func (r ApiToolLpSearchUsersRequest) ToolLpSearchUsersRequest(toolLpSearchUsersRequest ToolLpSearchUsersRequest) ApiToolLpSearchUsersRequest {
	r.toolLpSearchUsersRequest = &toolLpSearchUsersRequest
	return r
}

func (r ApiToolLpSearchUsersRequest) Execute() (*ToolLpSearchUsers200Response, *http.Response, error) {
	return r.ApiService.ToolLpSearchUsersExecute(r)
}

/*
ToolLpSearchUsers Search for users.

Search for users.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiToolLpSearchUsersRequest
*/
func (a *ToolLpAPIService) ToolLpSearchUsers(ctx context.Context) ApiToolLpSearchUsersRequest {
	return ApiToolLpSearchUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ToolLpSearchUsers200Response
func (a *ToolLpAPIService) ToolLpSearchUsersExecute(r ApiToolLpSearchUsersRequest) (*ToolLpSearchUsers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ToolLpSearchUsers200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ToolLpAPIService.ToolLpSearchUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tool_lp_search_users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.toolLpSearchUsersRequest == nil {
		return localVarReturnValue, nil, reportError("toolLpSearchUsersRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.toolLpSearchUsersRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
