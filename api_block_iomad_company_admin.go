/*
Moodle Webservice API

Auto-generated OpenAPI spec for Moodle's Webservice API. Requires installation of the Catalyst RESTful API plugin: https://github.com/catalyst/moodle-webservice_restful.

API version: 4.3.4
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package moodleclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// BlockIomadCompanyAdminAPIService BlockIomadCompanyAdminAPI service
type BlockIomadCompanyAdminAPIService service

type ApiBlockIomadCompanyAdminAllocateLicensesRequest struct {
	ctx context.Context
	ApiService *BlockIomadCompanyAdminAPIService
	blockIomadCompanyAdminAllocateLicensesRequest *BlockIomadCompanyAdminAllocateLicensesRequest
}

func (r ApiBlockIomadCompanyAdminAllocateLicensesRequest) BlockIomadCompanyAdminAllocateLicensesRequest(blockIomadCompanyAdminAllocateLicensesRequest BlockIomadCompanyAdminAllocateLicensesRequest) ApiBlockIomadCompanyAdminAllocateLicensesRequest {
	r.blockIomadCompanyAdminAllocateLicensesRequest = &blockIomadCompanyAdminAllocateLicensesRequest
	return r
}

func (r ApiBlockIomadCompanyAdminAllocateLicensesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.BlockIomadCompanyAdminAllocateLicensesExecute(r)
}

/*
BlockIomadCompanyAdminAllocateLicenses Allocate course licenses to a user

Allocate course licenses to a user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlockIomadCompanyAdminAllocateLicensesRequest
*/
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminAllocateLicenses(ctx context.Context) ApiBlockIomadCompanyAdminAllocateLicensesRequest {
	return ApiBlockIomadCompanyAdminAllocateLicensesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminAllocateLicensesExecute(r ApiBlockIomadCompanyAdminAllocateLicensesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockIomadCompanyAdminAPIService.BlockIomadCompanyAdminAllocateLicenses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block_iomad_company_admin_allocate_licenses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockIomadCompanyAdminAllocateLicensesRequest == nil {
		return localVarReturnValue, nil, reportError("blockIomadCompanyAdminAllocateLicensesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blockIomadCompanyAdminAllocateLicensesRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlockIomadCompanyAdminAssignCoursesRequest struct {
	ctx context.Context
	ApiService *BlockIomadCompanyAdminAPIService
	blockIomadCompanyAdminAssignCoursesRequest *BlockIomadCompanyAdminAssignCoursesRequest
}

func (r ApiBlockIomadCompanyAdminAssignCoursesRequest) BlockIomadCompanyAdminAssignCoursesRequest(blockIomadCompanyAdminAssignCoursesRequest BlockIomadCompanyAdminAssignCoursesRequest) ApiBlockIomadCompanyAdminAssignCoursesRequest {
	r.blockIomadCompanyAdminAssignCoursesRequest = &blockIomadCompanyAdminAssignCoursesRequest
	return r
}

func (r ApiBlockIomadCompanyAdminAssignCoursesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.BlockIomadCompanyAdminAssignCoursesExecute(r)
}

/*
BlockIomadCompanyAdminAssignCourses Assign a course to a company

Assign a course to a company

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlockIomadCompanyAdminAssignCoursesRequest
*/
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminAssignCourses(ctx context.Context) ApiBlockIomadCompanyAdminAssignCoursesRequest {
	return ApiBlockIomadCompanyAdminAssignCoursesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminAssignCoursesExecute(r ApiBlockIomadCompanyAdminAssignCoursesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockIomadCompanyAdminAPIService.BlockIomadCompanyAdminAssignCourses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block_iomad_company_admin_assign_courses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockIomadCompanyAdminAssignCoursesRequest == nil {
		return localVarReturnValue, nil, reportError("blockIomadCompanyAdminAssignCoursesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blockIomadCompanyAdminAssignCoursesRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlockIomadCompanyAdminAssignUsersRequest struct {
	ctx context.Context
	ApiService *BlockIomadCompanyAdminAPIService
	blockIomadCompanyAdminAssignUsersRequest *BlockIomadCompanyAdminAssignUsersRequest
}

func (r ApiBlockIomadCompanyAdminAssignUsersRequest) BlockIomadCompanyAdminAssignUsersRequest(blockIomadCompanyAdminAssignUsersRequest BlockIomadCompanyAdminAssignUsersRequest) ApiBlockIomadCompanyAdminAssignUsersRequest {
	r.blockIomadCompanyAdminAssignUsersRequest = &blockIomadCompanyAdminAssignUsersRequest
	return r
}

func (r ApiBlockIomadCompanyAdminAssignUsersRequest) Execute() (*BlockIomadCompanyAdminAssignUsers200Response, *http.Response, error) {
	return r.ApiService.BlockIomadCompanyAdminAssignUsersExecute(r)
}

/*
BlockIomadCompanyAdminAssignUsers Assign users to a company

Assign users to a company

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlockIomadCompanyAdminAssignUsersRequest
*/
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminAssignUsers(ctx context.Context) ApiBlockIomadCompanyAdminAssignUsersRequest {
	return ApiBlockIomadCompanyAdminAssignUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BlockIomadCompanyAdminAssignUsers200Response
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminAssignUsersExecute(r ApiBlockIomadCompanyAdminAssignUsersRequest) (*BlockIomadCompanyAdminAssignUsers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockIomadCompanyAdminAssignUsers200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockIomadCompanyAdminAPIService.BlockIomadCompanyAdminAssignUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block_iomad_company_admin_assign_users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockIomadCompanyAdminAssignUsersRequest == nil {
		return localVarReturnValue, nil, reportError("blockIomadCompanyAdminAssignUsersRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blockIomadCompanyAdminAssignUsersRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlockIomadCompanyAdminCapabilityDeleteTemplateRequest struct {
	ctx context.Context
	ApiService *BlockIomadCompanyAdminAPIService
	blockIomadCompanyAdminCapabilityDeleteTemplateRequest *BlockIomadCompanyAdminCapabilityDeleteTemplateRequest
}

func (r ApiBlockIomadCompanyAdminCapabilityDeleteTemplateRequest) BlockIomadCompanyAdminCapabilityDeleteTemplateRequest(blockIomadCompanyAdminCapabilityDeleteTemplateRequest BlockIomadCompanyAdminCapabilityDeleteTemplateRequest) ApiBlockIomadCompanyAdminCapabilityDeleteTemplateRequest {
	r.blockIomadCompanyAdminCapabilityDeleteTemplateRequest = &blockIomadCompanyAdminCapabilityDeleteTemplateRequest
	return r
}

func (r ApiBlockIomadCompanyAdminCapabilityDeleteTemplateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.BlockIomadCompanyAdminCapabilityDeleteTemplateExecute(r)
}

/*
BlockIomadCompanyAdminCapabilityDeleteTemplate Delete Iomad capabilities template

Delete Iomad capabilities template

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlockIomadCompanyAdminCapabilityDeleteTemplateRequest
*/
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminCapabilityDeleteTemplate(ctx context.Context) ApiBlockIomadCompanyAdminCapabilityDeleteTemplateRequest {
	return ApiBlockIomadCompanyAdminCapabilityDeleteTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminCapabilityDeleteTemplateExecute(r ApiBlockIomadCompanyAdminCapabilityDeleteTemplateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockIomadCompanyAdminAPIService.BlockIomadCompanyAdminCapabilityDeleteTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block_iomad_company_admin_capability_delete_template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockIomadCompanyAdminCapabilityDeleteTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("blockIomadCompanyAdminCapabilityDeleteTemplateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blockIomadCompanyAdminCapabilityDeleteTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlockIomadCompanyAdminCheckTokenRequest struct {
	ctx context.Context
	ApiService *BlockIomadCompanyAdminAPIService
	blockIomadCompanyAdminCheckTokenRequest *BlockIomadCompanyAdminCheckTokenRequest
}

func (r ApiBlockIomadCompanyAdminCheckTokenRequest) BlockIomadCompanyAdminCheckTokenRequest(blockIomadCompanyAdminCheckTokenRequest BlockIomadCompanyAdminCheckTokenRequest) ApiBlockIomadCompanyAdminCheckTokenRequest {
	r.blockIomadCompanyAdminCheckTokenRequest = &blockIomadCompanyAdminCheckTokenRequest
	return r
}

func (r ApiBlockIomadCompanyAdminCheckTokenRequest) Execute() (*BlockIomadCompanyAdminCheckToken200Response, *http.Response, error) {
	return r.ApiService.BlockIomadCompanyAdminCheckTokenExecute(r)
}

/*
BlockIomadCompanyAdminCheckToken Check SSO token

Check SSO token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlockIomadCompanyAdminCheckTokenRequest
*/
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminCheckToken(ctx context.Context) ApiBlockIomadCompanyAdminCheckTokenRequest {
	return ApiBlockIomadCompanyAdminCheckTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BlockIomadCompanyAdminCheckToken200Response
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminCheckTokenExecute(r ApiBlockIomadCompanyAdminCheckTokenRequest) (*BlockIomadCompanyAdminCheckToken200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockIomadCompanyAdminCheckToken200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockIomadCompanyAdminAPIService.BlockIomadCompanyAdminCheckToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block_iomad_company_admin_check_token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockIomadCompanyAdminCheckTokenRequest == nil {
		return localVarReturnValue, nil, reportError("blockIomadCompanyAdminCheckTokenRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blockIomadCompanyAdminCheckTokenRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlockIomadCompanyAdminCreateCompaniesRequest struct {
	ctx context.Context
	ApiService *BlockIomadCompanyAdminAPIService
	blockIomadCompanyAdminCreateCompaniesRequest *BlockIomadCompanyAdminCreateCompaniesRequest
}

func (r ApiBlockIomadCompanyAdminCreateCompaniesRequest) BlockIomadCompanyAdminCreateCompaniesRequest(blockIomadCompanyAdminCreateCompaniesRequest BlockIomadCompanyAdminCreateCompaniesRequest) ApiBlockIomadCompanyAdminCreateCompaniesRequest {
	r.blockIomadCompanyAdminCreateCompaniesRequest = &blockIomadCompanyAdminCreateCompaniesRequest
	return r
}

func (r ApiBlockIomadCompanyAdminCreateCompaniesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.BlockIomadCompanyAdminCreateCompaniesExecute(r)
}

/*
BlockIomadCompanyAdminCreateCompanies Create new Iomad companies

Create new Iomad companies

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlockIomadCompanyAdminCreateCompaniesRequest
*/
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminCreateCompanies(ctx context.Context) ApiBlockIomadCompanyAdminCreateCompaniesRequest {
	return ApiBlockIomadCompanyAdminCreateCompaniesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminCreateCompaniesExecute(r ApiBlockIomadCompanyAdminCreateCompaniesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockIomadCompanyAdminAPIService.BlockIomadCompanyAdminCreateCompanies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block_iomad_company_admin_create_companies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockIomadCompanyAdminCreateCompaniesRequest == nil {
		return localVarReturnValue, nil, reportError("blockIomadCompanyAdminCreateCompaniesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blockIomadCompanyAdminCreateCompaniesRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlockIomadCompanyAdminCreateLicensesRequest struct {
	ctx context.Context
	ApiService *BlockIomadCompanyAdminAPIService
	blockIomadCompanyAdminCreateLicensesRequest *BlockIomadCompanyAdminCreateLicensesRequest
}

func (r ApiBlockIomadCompanyAdminCreateLicensesRequest) BlockIomadCompanyAdminCreateLicensesRequest(blockIomadCompanyAdminCreateLicensesRequest BlockIomadCompanyAdminCreateLicensesRequest) ApiBlockIomadCompanyAdminCreateLicensesRequest {
	r.blockIomadCompanyAdminCreateLicensesRequest = &blockIomadCompanyAdminCreateLicensesRequest
	return r
}

func (r ApiBlockIomadCompanyAdminCreateLicensesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.BlockIomadCompanyAdminCreateLicensesExecute(r)
}

/*
BlockIomadCompanyAdminCreateLicenses Create company licenses

Create company licenses

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlockIomadCompanyAdminCreateLicensesRequest
*/
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminCreateLicenses(ctx context.Context) ApiBlockIomadCompanyAdminCreateLicensesRequest {
	return ApiBlockIomadCompanyAdminCreateLicensesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminCreateLicensesExecute(r ApiBlockIomadCompanyAdminCreateLicensesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockIomadCompanyAdminAPIService.BlockIomadCompanyAdminCreateLicenses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block_iomad_company_admin_create_licenses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockIomadCompanyAdminCreateLicensesRequest == nil {
		return localVarReturnValue, nil, reportError("blockIomadCompanyAdminCreateLicensesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blockIomadCompanyAdminCreateLicensesRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlockIomadCompanyAdminDeleteLicensesRequest struct {
	ctx context.Context
	ApiService *BlockIomadCompanyAdminAPIService
	blockIomadCompanyAdminDeleteLicensesRequest *BlockIomadCompanyAdminDeleteLicensesRequest
}

func (r ApiBlockIomadCompanyAdminDeleteLicensesRequest) BlockIomadCompanyAdminDeleteLicensesRequest(blockIomadCompanyAdminDeleteLicensesRequest BlockIomadCompanyAdminDeleteLicensesRequest) ApiBlockIomadCompanyAdminDeleteLicensesRequest {
	r.blockIomadCompanyAdminDeleteLicensesRequest = &blockIomadCompanyAdminDeleteLicensesRequest
	return r
}

func (r ApiBlockIomadCompanyAdminDeleteLicensesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.BlockIomadCompanyAdminDeleteLicensesExecute(r)
}

/*
BlockIomadCompanyAdminDeleteLicenses Delete company licenses

Delete company licenses

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlockIomadCompanyAdminDeleteLicensesRequest
*/
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminDeleteLicenses(ctx context.Context) ApiBlockIomadCompanyAdminDeleteLicensesRequest {
	return ApiBlockIomadCompanyAdminDeleteLicensesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminDeleteLicensesExecute(r ApiBlockIomadCompanyAdminDeleteLicensesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockIomadCompanyAdminAPIService.BlockIomadCompanyAdminDeleteLicenses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block_iomad_company_admin_delete_licenses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockIomadCompanyAdminDeleteLicensesRequest == nil {
		return localVarReturnValue, nil, reportError("blockIomadCompanyAdminDeleteLicensesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blockIomadCompanyAdminDeleteLicensesRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlockIomadCompanyAdminEditCompaniesRequest struct {
	ctx context.Context
	ApiService *BlockIomadCompanyAdminAPIService
	blockIomadCompanyAdminEditCompaniesRequest *BlockIomadCompanyAdminEditCompaniesRequest
}

func (r ApiBlockIomadCompanyAdminEditCompaniesRequest) BlockIomadCompanyAdminEditCompaniesRequest(blockIomadCompanyAdminEditCompaniesRequest BlockIomadCompanyAdminEditCompaniesRequest) ApiBlockIomadCompanyAdminEditCompaniesRequest {
	r.blockIomadCompanyAdminEditCompaniesRequest = &blockIomadCompanyAdminEditCompaniesRequest
	return r
}

func (r ApiBlockIomadCompanyAdminEditCompaniesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.BlockIomadCompanyAdminEditCompaniesExecute(r)
}

/*
BlockIomadCompanyAdminEditCompanies Edit Iomad companies

Edit Iomad companies

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlockIomadCompanyAdminEditCompaniesRequest
*/
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminEditCompanies(ctx context.Context) ApiBlockIomadCompanyAdminEditCompaniesRequest {
	return ApiBlockIomadCompanyAdminEditCompaniesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminEditCompaniesExecute(r ApiBlockIomadCompanyAdminEditCompaniesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockIomadCompanyAdminAPIService.BlockIomadCompanyAdminEditCompanies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block_iomad_company_admin_edit_companies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockIomadCompanyAdminEditCompaniesRequest == nil {
		return localVarReturnValue, nil, reportError("blockIomadCompanyAdminEditCompaniesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blockIomadCompanyAdminEditCompaniesRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlockIomadCompanyAdminEditLicensesRequest struct {
	ctx context.Context
	ApiService *BlockIomadCompanyAdminAPIService
	blockIomadCompanyAdminEditLicensesRequest *BlockIomadCompanyAdminEditLicensesRequest
}

func (r ApiBlockIomadCompanyAdminEditLicensesRequest) BlockIomadCompanyAdminEditLicensesRequest(blockIomadCompanyAdminEditLicensesRequest BlockIomadCompanyAdminEditLicensesRequest) ApiBlockIomadCompanyAdminEditLicensesRequest {
	r.blockIomadCompanyAdminEditLicensesRequest = &blockIomadCompanyAdminEditLicensesRequest
	return r
}

func (r ApiBlockIomadCompanyAdminEditLicensesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.BlockIomadCompanyAdminEditLicensesExecute(r)
}

/*
BlockIomadCompanyAdminEditLicenses Edit company license settings

Edit company license settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlockIomadCompanyAdminEditLicensesRequest
*/
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminEditLicenses(ctx context.Context) ApiBlockIomadCompanyAdminEditLicensesRequest {
	return ApiBlockIomadCompanyAdminEditLicensesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminEditLicensesExecute(r ApiBlockIomadCompanyAdminEditLicensesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockIomadCompanyAdminAPIService.BlockIomadCompanyAdminEditLicenses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block_iomad_company_admin_edit_licenses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockIomadCompanyAdminEditLicensesRequest == nil {
		return localVarReturnValue, nil, reportError("blockIomadCompanyAdminEditLicensesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blockIomadCompanyAdminEditLicensesRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlockIomadCompanyAdminEnrolUsersRequest struct {
	ctx context.Context
	ApiService *BlockIomadCompanyAdminAPIService
	blockIomadCompanyAdminEnrolUsersRequest *BlockIomadCompanyAdminEnrolUsersRequest
}

func (r ApiBlockIomadCompanyAdminEnrolUsersRequest) BlockIomadCompanyAdminEnrolUsersRequest(blockIomadCompanyAdminEnrolUsersRequest BlockIomadCompanyAdminEnrolUsersRequest) ApiBlockIomadCompanyAdminEnrolUsersRequest {
	r.blockIomadCompanyAdminEnrolUsersRequest = &blockIomadCompanyAdminEnrolUsersRequest
	return r
}

func (r ApiBlockIomadCompanyAdminEnrolUsersRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.BlockIomadCompanyAdminEnrolUsersExecute(r)
}

/*
BlockIomadCompanyAdminEnrolUsers Assign users onto courses

Assign users onto courses

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlockIomadCompanyAdminEnrolUsersRequest
*/
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminEnrolUsers(ctx context.Context) ApiBlockIomadCompanyAdminEnrolUsersRequest {
	return ApiBlockIomadCompanyAdminEnrolUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminEnrolUsersExecute(r ApiBlockIomadCompanyAdminEnrolUsersRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockIomadCompanyAdminAPIService.BlockIomadCompanyAdminEnrolUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block_iomad_company_admin_enrol_users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockIomadCompanyAdminEnrolUsersRequest == nil {
		return localVarReturnValue, nil, reportError("blockIomadCompanyAdminEnrolUsersRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blockIomadCompanyAdminEnrolUsersRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlockIomadCompanyAdminGetCompaniesRequest struct {
	ctx context.Context
	ApiService *BlockIomadCompanyAdminAPIService
	blockIomadCompanyAdminGetCompaniesRequest *BlockIomadCompanyAdminGetCompaniesRequest
}

func (r ApiBlockIomadCompanyAdminGetCompaniesRequest) BlockIomadCompanyAdminGetCompaniesRequest(blockIomadCompanyAdminGetCompaniesRequest BlockIomadCompanyAdminGetCompaniesRequest) ApiBlockIomadCompanyAdminGetCompaniesRequest {
	r.blockIomadCompanyAdminGetCompaniesRequest = &blockIomadCompanyAdminGetCompaniesRequest
	return r
}

func (r ApiBlockIomadCompanyAdminGetCompaniesRequest) Execute() (*BlockIomadCompanyAdminGetCompanies200Response, *http.Response, error) {
	return r.ApiService.BlockIomadCompanyAdminGetCompaniesExecute(r)
}

/*
BlockIomadCompanyAdminGetCompanies Get all Iomad companies

Get all Iomad companies

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlockIomadCompanyAdminGetCompaniesRequest
*/
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminGetCompanies(ctx context.Context) ApiBlockIomadCompanyAdminGetCompaniesRequest {
	return ApiBlockIomadCompanyAdminGetCompaniesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BlockIomadCompanyAdminGetCompanies200Response
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminGetCompaniesExecute(r ApiBlockIomadCompanyAdminGetCompaniesRequest) (*BlockIomadCompanyAdminGetCompanies200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockIomadCompanyAdminGetCompanies200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockIomadCompanyAdminAPIService.BlockIomadCompanyAdminGetCompanies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block_iomad_company_admin_get_companies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockIomadCompanyAdminGetCompaniesRequest == nil {
		return localVarReturnValue, nil, reportError("blockIomadCompanyAdminGetCompaniesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blockIomadCompanyAdminGetCompaniesRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlockIomadCompanyAdminGetCompanyCoursesRequest struct {
	ctx context.Context
	ApiService *BlockIomadCompanyAdminAPIService
	blockIomadCompanyAdminGetCompanyCoursesRequest *BlockIomadCompanyAdminGetCompanyCoursesRequest
}

func (r ApiBlockIomadCompanyAdminGetCompanyCoursesRequest) BlockIomadCompanyAdminGetCompanyCoursesRequest(blockIomadCompanyAdminGetCompanyCoursesRequest BlockIomadCompanyAdminGetCompanyCoursesRequest) ApiBlockIomadCompanyAdminGetCompanyCoursesRequest {
	r.blockIomadCompanyAdminGetCompanyCoursesRequest = &blockIomadCompanyAdminGetCompanyCoursesRequest
	return r
}

func (r ApiBlockIomadCompanyAdminGetCompanyCoursesRequest) Execute() (*BlockIomadCompanyAdminGetCompanyCourses200Response, *http.Response, error) {
	return r.ApiService.BlockIomadCompanyAdminGetCompanyCoursesExecute(r)
}

/*
BlockIomadCompanyAdminGetCompanyCourses Get Iomad company course allocations

Get Iomad company course allocations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlockIomadCompanyAdminGetCompanyCoursesRequest
*/
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminGetCompanyCourses(ctx context.Context) ApiBlockIomadCompanyAdminGetCompanyCoursesRequest {
	return ApiBlockIomadCompanyAdminGetCompanyCoursesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BlockIomadCompanyAdminGetCompanyCourses200Response
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminGetCompanyCoursesExecute(r ApiBlockIomadCompanyAdminGetCompanyCoursesRequest) (*BlockIomadCompanyAdminGetCompanyCourses200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockIomadCompanyAdminGetCompanyCourses200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockIomadCompanyAdminAPIService.BlockIomadCompanyAdminGetCompanyCourses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block_iomad_company_admin_get_company_courses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockIomadCompanyAdminGetCompanyCoursesRequest == nil {
		return localVarReturnValue, nil, reportError("blockIomadCompanyAdminGetCompanyCoursesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blockIomadCompanyAdminGetCompanyCoursesRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlockIomadCompanyAdminGetCourseInfoRequest struct {
	ctx context.Context
	ApiService *BlockIomadCompanyAdminAPIService
	blockIomadCompanyAdminGetCourseInfoRequest *BlockIomadCompanyAdminGetCourseInfoRequest
}

func (r ApiBlockIomadCompanyAdminGetCourseInfoRequest) BlockIomadCompanyAdminGetCourseInfoRequest(blockIomadCompanyAdminGetCourseInfoRequest BlockIomadCompanyAdminGetCourseInfoRequest) ApiBlockIomadCompanyAdminGetCourseInfoRequest {
	r.blockIomadCompanyAdminGetCourseInfoRequest = &blockIomadCompanyAdminGetCourseInfoRequest
	return r
}

func (r ApiBlockIomadCompanyAdminGetCourseInfoRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.BlockIomadCompanyAdminGetCourseInfoExecute(r)
}

/*
BlockIomadCompanyAdminGetCourseInfo Get Iomad course settings

Get Iomad course settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlockIomadCompanyAdminGetCourseInfoRequest
*/
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminGetCourseInfo(ctx context.Context) ApiBlockIomadCompanyAdminGetCourseInfoRequest {
	return ApiBlockIomadCompanyAdminGetCourseInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminGetCourseInfoExecute(r ApiBlockIomadCompanyAdminGetCourseInfoRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockIomadCompanyAdminAPIService.BlockIomadCompanyAdminGetCourseInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block_iomad_company_admin_get_course_info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockIomadCompanyAdminGetCourseInfoRequest == nil {
		return localVarReturnValue, nil, reportError("blockIomadCompanyAdminGetCourseInfoRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blockIomadCompanyAdminGetCourseInfoRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlockIomadCompanyAdminGetDepartmentUsersRequest struct {
	ctx context.Context
	ApiService *BlockIomadCompanyAdminAPIService
	blockIomadCompanyAdminGetDepartmentUsersRequest *BlockIomadCompanyAdminGetDepartmentUsersRequest
}

func (r ApiBlockIomadCompanyAdminGetDepartmentUsersRequest) BlockIomadCompanyAdminGetDepartmentUsersRequest(blockIomadCompanyAdminGetDepartmentUsersRequest BlockIomadCompanyAdminGetDepartmentUsersRequest) ApiBlockIomadCompanyAdminGetDepartmentUsersRequest {
	r.blockIomadCompanyAdminGetDepartmentUsersRequest = &blockIomadCompanyAdminGetDepartmentUsersRequest
	return r
}

func (r ApiBlockIomadCompanyAdminGetDepartmentUsersRequest) Execute() (*BlockIomadCompanyAdminGetDepartmentUsers200Response, *http.Response, error) {
	return r.ApiService.BlockIomadCompanyAdminGetDepartmentUsersExecute(r)
}

/*
BlockIomadCompanyAdminGetDepartmentUsers Get users within a department

Get users within a department

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlockIomadCompanyAdminGetDepartmentUsersRequest
*/
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminGetDepartmentUsers(ctx context.Context) ApiBlockIomadCompanyAdminGetDepartmentUsersRequest {
	return ApiBlockIomadCompanyAdminGetDepartmentUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BlockIomadCompanyAdminGetDepartmentUsers200Response
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminGetDepartmentUsersExecute(r ApiBlockIomadCompanyAdminGetDepartmentUsersRequest) (*BlockIomadCompanyAdminGetDepartmentUsers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockIomadCompanyAdminGetDepartmentUsers200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockIomadCompanyAdminAPIService.BlockIomadCompanyAdminGetDepartmentUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block_iomad_company_admin_get_department_users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockIomadCompanyAdminGetDepartmentUsersRequest == nil {
		return localVarReturnValue, nil, reportError("blockIomadCompanyAdminGetDepartmentUsersRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blockIomadCompanyAdminGetDepartmentUsersRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlockIomadCompanyAdminGetDepartmentsRequest struct {
	ctx context.Context
	ApiService *BlockIomadCompanyAdminAPIService
	blockIomadCompanyAdminGetDepartmentsRequest *BlockIomadCompanyAdminGetDepartmentsRequest
}

func (r ApiBlockIomadCompanyAdminGetDepartmentsRequest) BlockIomadCompanyAdminGetDepartmentsRequest(blockIomadCompanyAdminGetDepartmentsRequest BlockIomadCompanyAdminGetDepartmentsRequest) ApiBlockIomadCompanyAdminGetDepartmentsRequest {
	r.blockIomadCompanyAdminGetDepartmentsRequest = &blockIomadCompanyAdminGetDepartmentsRequest
	return r
}

func (r ApiBlockIomadCompanyAdminGetDepartmentsRequest) Execute() (*BlockIomadCompanyAdminGetDepartments200Response, *http.Response, error) {
	return r.ApiService.BlockIomadCompanyAdminGetDepartmentsExecute(r)
}

/*
BlockIomadCompanyAdminGetDepartments Get all company departments

Get all company departments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlockIomadCompanyAdminGetDepartmentsRequest
*/
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminGetDepartments(ctx context.Context) ApiBlockIomadCompanyAdminGetDepartmentsRequest {
	return ApiBlockIomadCompanyAdminGetDepartmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BlockIomadCompanyAdminGetDepartments200Response
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminGetDepartmentsExecute(r ApiBlockIomadCompanyAdminGetDepartmentsRequest) (*BlockIomadCompanyAdminGetDepartments200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockIomadCompanyAdminGetDepartments200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockIomadCompanyAdminAPIService.BlockIomadCompanyAdminGetDepartments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block_iomad_company_admin_get_departments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockIomadCompanyAdminGetDepartmentsRequest == nil {
		return localVarReturnValue, nil, reportError("blockIomadCompanyAdminGetDepartmentsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blockIomadCompanyAdminGetDepartmentsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlockIomadCompanyAdminGetLicenseFromIdRequest struct {
	ctx context.Context
	ApiService *BlockIomadCompanyAdminAPIService
	blockIomadCompanyAdminGetLicenseFromIdRequest *BlockIomadCompanyAdminGetLicenseFromIdRequest
}

func (r ApiBlockIomadCompanyAdminGetLicenseFromIdRequest) BlockIomadCompanyAdminGetLicenseFromIdRequest(blockIomadCompanyAdminGetLicenseFromIdRequest BlockIomadCompanyAdminGetLicenseFromIdRequest) ApiBlockIomadCompanyAdminGetLicenseFromIdRequest {
	r.blockIomadCompanyAdminGetLicenseFromIdRequest = &blockIomadCompanyAdminGetLicenseFromIdRequest
	return r
}

func (r ApiBlockIomadCompanyAdminGetLicenseFromIdRequest) Execute() (*BlockIomadCompanyAdminGetLicenseFromId200Response, *http.Response, error) {
	return r.ApiService.BlockIomadCompanyAdminGetLicenseFromIdExecute(r)
}

/*
BlockIomadCompanyAdminGetLicenseFromId Get licence data give the ID

Get licence data give the ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlockIomadCompanyAdminGetLicenseFromIdRequest
*/
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminGetLicenseFromId(ctx context.Context) ApiBlockIomadCompanyAdminGetLicenseFromIdRequest {
	return ApiBlockIomadCompanyAdminGetLicenseFromIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BlockIomadCompanyAdminGetLicenseFromId200Response
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminGetLicenseFromIdExecute(r ApiBlockIomadCompanyAdminGetLicenseFromIdRequest) (*BlockIomadCompanyAdminGetLicenseFromId200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockIomadCompanyAdminGetLicenseFromId200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockIomadCompanyAdminAPIService.BlockIomadCompanyAdminGetLicenseFromId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block_iomad_company_admin_get_license_from_id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockIomadCompanyAdminGetLicenseFromIdRequest == nil {
		return localVarReturnValue, nil, reportError("blockIomadCompanyAdminGetLicenseFromIdRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blockIomadCompanyAdminGetLicenseFromIdRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlockIomadCompanyAdminGetLicenseInfoRequest struct {
	ctx context.Context
	ApiService *BlockIomadCompanyAdminAPIService
	blockIomadCompanyAdminGetLicenseInfoRequest *BlockIomadCompanyAdminGetLicenseInfoRequest
}

func (r ApiBlockIomadCompanyAdminGetLicenseInfoRequest) BlockIomadCompanyAdminGetLicenseInfoRequest(blockIomadCompanyAdminGetLicenseInfoRequest BlockIomadCompanyAdminGetLicenseInfoRequest) ApiBlockIomadCompanyAdminGetLicenseInfoRequest {
	r.blockIomadCompanyAdminGetLicenseInfoRequest = &blockIomadCompanyAdminGetLicenseInfoRequest
	return r
}

func (r ApiBlockIomadCompanyAdminGetLicenseInfoRequest) Execute() (*BlockIomadCompanyAdminGetLicenseInfo200Response, *http.Response, error) {
	return r.ApiService.BlockIomadCompanyAdminGetLicenseInfoExecute(r)
}

/*
BlockIomadCompanyAdminGetLicenseInfo Get company license information

Get company license information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlockIomadCompanyAdminGetLicenseInfoRequest
*/
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminGetLicenseInfo(ctx context.Context) ApiBlockIomadCompanyAdminGetLicenseInfoRequest {
	return ApiBlockIomadCompanyAdminGetLicenseInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BlockIomadCompanyAdminGetLicenseInfo200Response
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminGetLicenseInfoExecute(r ApiBlockIomadCompanyAdminGetLicenseInfoRequest) (*BlockIomadCompanyAdminGetLicenseInfo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockIomadCompanyAdminGetLicenseInfo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockIomadCompanyAdminAPIService.BlockIomadCompanyAdminGetLicenseInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block_iomad_company_admin_get_license_info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockIomadCompanyAdminGetLicenseInfoRequest == nil {
		return localVarReturnValue, nil, reportError("blockIomadCompanyAdminGetLicenseInfoRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blockIomadCompanyAdminGetLicenseInfoRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlockIomadCompanyAdminMoveUsersRequest struct {
	ctx context.Context
	ApiService *BlockIomadCompanyAdminAPIService
	blockIomadCompanyAdminMoveUsersRequest *BlockIomadCompanyAdminMoveUsersRequest
}

func (r ApiBlockIomadCompanyAdminMoveUsersRequest) BlockIomadCompanyAdminMoveUsersRequest(blockIomadCompanyAdminMoveUsersRequest BlockIomadCompanyAdminMoveUsersRequest) ApiBlockIomadCompanyAdminMoveUsersRequest {
	r.blockIomadCompanyAdminMoveUsersRequest = &blockIomadCompanyAdminMoveUsersRequest
	return r
}

func (r ApiBlockIomadCompanyAdminMoveUsersRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.BlockIomadCompanyAdminMoveUsersExecute(r)
}

/*
BlockIomadCompanyAdminMoveUsers Move users between departments

Move users between departments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlockIomadCompanyAdminMoveUsersRequest
*/
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminMoveUsers(ctx context.Context) ApiBlockIomadCompanyAdminMoveUsersRequest {
	return ApiBlockIomadCompanyAdminMoveUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminMoveUsersExecute(r ApiBlockIomadCompanyAdminMoveUsersRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockIomadCompanyAdminAPIService.BlockIomadCompanyAdminMoveUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block_iomad_company_admin_move_users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockIomadCompanyAdminMoveUsersRequest == nil {
		return localVarReturnValue, nil, reportError("blockIomadCompanyAdminMoveUsersRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blockIomadCompanyAdminMoveUsersRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlockIomadCompanyAdminRestrictCapabilityRequest struct {
	ctx context.Context
	ApiService *BlockIomadCompanyAdminAPIService
	blockIomadCompanyAdminRestrictCapabilityRequest *BlockIomadCompanyAdminRestrictCapabilityRequest
}

func (r ApiBlockIomadCompanyAdminRestrictCapabilityRequest) BlockIomadCompanyAdminRestrictCapabilityRequest(blockIomadCompanyAdminRestrictCapabilityRequest BlockIomadCompanyAdminRestrictCapabilityRequest) ApiBlockIomadCompanyAdminRestrictCapabilityRequest {
	r.blockIomadCompanyAdminRestrictCapabilityRequest = &blockIomadCompanyAdminRestrictCapabilityRequest
	return r
}

func (r ApiBlockIomadCompanyAdminRestrictCapabilityRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.BlockIomadCompanyAdminRestrictCapabilityExecute(r)
}

/*
BlockIomadCompanyAdminRestrictCapability set/reset Iomad capability

set/reset Iomad capability

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlockIomadCompanyAdminRestrictCapabilityRequest
*/
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminRestrictCapability(ctx context.Context) ApiBlockIomadCompanyAdminRestrictCapabilityRequest {
	return ApiBlockIomadCompanyAdminRestrictCapabilityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminRestrictCapabilityExecute(r ApiBlockIomadCompanyAdminRestrictCapabilityRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockIomadCompanyAdminAPIService.BlockIomadCompanyAdminRestrictCapability")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block_iomad_company_admin_restrict_capability"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockIomadCompanyAdminRestrictCapabilityRequest == nil {
		return localVarReturnValue, nil, reportError("blockIomadCompanyAdminRestrictCapabilityRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blockIomadCompanyAdminRestrictCapabilityRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlockIomadCompanyAdminSyncUsersRequest struct {
	ctx context.Context
	ApiService *BlockIomadCompanyAdminAPIService
	blockIomadCompanyAdminSyncUsersRequest *BlockIomadCompanyAdminSyncUsersRequest
}

func (r ApiBlockIomadCompanyAdminSyncUsersRequest) BlockIomadCompanyAdminSyncUsersRequest(blockIomadCompanyAdminSyncUsersRequest BlockIomadCompanyAdminSyncUsersRequest) ApiBlockIomadCompanyAdminSyncUsersRequest {
	r.blockIomadCompanyAdminSyncUsersRequest = &blockIomadCompanyAdminSyncUsersRequest
	return r
}

func (r ApiBlockIomadCompanyAdminSyncUsersRequest) Execute() (*BlockIomadCompanyAdminSyncUsers200Response, *http.Response, error) {
	return r.ApiService.BlockIomadCompanyAdminSyncUsersExecute(r)
}

/*
BlockIomadCompanyAdminSyncUsers Call update users to sync to external system

Call update users to sync to external system

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlockIomadCompanyAdminSyncUsersRequest
*/
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminSyncUsers(ctx context.Context) ApiBlockIomadCompanyAdminSyncUsersRequest {
	return ApiBlockIomadCompanyAdminSyncUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BlockIomadCompanyAdminSyncUsers200Response
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminSyncUsersExecute(r ApiBlockIomadCompanyAdminSyncUsersRequest) (*BlockIomadCompanyAdminSyncUsers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockIomadCompanyAdminSyncUsers200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockIomadCompanyAdminAPIService.BlockIomadCompanyAdminSyncUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block_iomad_company_admin_sync_users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockIomadCompanyAdminSyncUsersRequest == nil {
		return localVarReturnValue, nil, reportError("blockIomadCompanyAdminSyncUsersRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blockIomadCompanyAdminSyncUsersRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlockIomadCompanyAdminUnallocateLicensesRequest struct {
	ctx context.Context
	ApiService *BlockIomadCompanyAdminAPIService
	blockIomadCompanyAdminUnallocateLicensesRequest *BlockIomadCompanyAdminUnallocateLicensesRequest
}

func (r ApiBlockIomadCompanyAdminUnallocateLicensesRequest) BlockIomadCompanyAdminUnallocateLicensesRequest(blockIomadCompanyAdminUnallocateLicensesRequest BlockIomadCompanyAdminUnallocateLicensesRequest) ApiBlockIomadCompanyAdminUnallocateLicensesRequest {
	r.blockIomadCompanyAdminUnallocateLicensesRequest = &blockIomadCompanyAdminUnallocateLicensesRequest
	return r
}

func (r ApiBlockIomadCompanyAdminUnallocateLicensesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.BlockIomadCompanyAdminUnallocateLicensesExecute(r)
}

/*
BlockIomadCompanyAdminUnallocateLicenses Remove course licenses from users

Remove course licenses from users

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlockIomadCompanyAdminUnallocateLicensesRequest
*/
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminUnallocateLicenses(ctx context.Context) ApiBlockIomadCompanyAdminUnallocateLicensesRequest {
	return ApiBlockIomadCompanyAdminUnallocateLicensesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminUnallocateLicensesExecute(r ApiBlockIomadCompanyAdminUnallocateLicensesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockIomadCompanyAdminAPIService.BlockIomadCompanyAdminUnallocateLicenses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block_iomad_company_admin_unallocate_licenses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockIomadCompanyAdminUnallocateLicensesRequest == nil {
		return localVarReturnValue, nil, reportError("blockIomadCompanyAdminUnallocateLicensesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blockIomadCompanyAdminUnallocateLicensesRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlockIomadCompanyAdminUnassignCoursesRequest struct {
	ctx context.Context
	ApiService *BlockIomadCompanyAdminAPIService
	blockIomadCompanyAdminUnassignCoursesRequest *BlockIomadCompanyAdminUnassignCoursesRequest
}

func (r ApiBlockIomadCompanyAdminUnassignCoursesRequest) BlockIomadCompanyAdminUnassignCoursesRequest(blockIomadCompanyAdminUnassignCoursesRequest BlockIomadCompanyAdminUnassignCoursesRequest) ApiBlockIomadCompanyAdminUnassignCoursesRequest {
	r.blockIomadCompanyAdminUnassignCoursesRequest = &blockIomadCompanyAdminUnassignCoursesRequest
	return r
}

func (r ApiBlockIomadCompanyAdminUnassignCoursesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.BlockIomadCompanyAdminUnassignCoursesExecute(r)
}

/*
BlockIomadCompanyAdminUnassignCourses Unassign a course from a company

Unassign a course from a company

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlockIomadCompanyAdminUnassignCoursesRequest
*/
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminUnassignCourses(ctx context.Context) ApiBlockIomadCompanyAdminUnassignCoursesRequest {
	return ApiBlockIomadCompanyAdminUnassignCoursesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminUnassignCoursesExecute(r ApiBlockIomadCompanyAdminUnassignCoursesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockIomadCompanyAdminAPIService.BlockIomadCompanyAdminUnassignCourses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block_iomad_company_admin_unassign_courses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockIomadCompanyAdminUnassignCoursesRequest == nil {
		return localVarReturnValue, nil, reportError("blockIomadCompanyAdminUnassignCoursesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blockIomadCompanyAdminUnassignCoursesRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlockIomadCompanyAdminUnassignUsersRequest struct {
	ctx context.Context
	ApiService *BlockIomadCompanyAdminAPIService
	blockIomadCompanyAdminUnassignUsersRequest *BlockIomadCompanyAdminUnassignUsersRequest
}

func (r ApiBlockIomadCompanyAdminUnassignUsersRequest) BlockIomadCompanyAdminUnassignUsersRequest(blockIomadCompanyAdminUnassignUsersRequest BlockIomadCompanyAdminUnassignUsersRequest) ApiBlockIomadCompanyAdminUnassignUsersRequest {
	r.blockIomadCompanyAdminUnassignUsersRequest = &blockIomadCompanyAdminUnassignUsersRequest
	return r
}

func (r ApiBlockIomadCompanyAdminUnassignUsersRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.BlockIomadCompanyAdminUnassignUsersExecute(r)
}

/*
BlockIomadCompanyAdminUnassignUsers Unassign users from a company

Unassign users from a company

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlockIomadCompanyAdminUnassignUsersRequest
*/
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminUnassignUsers(ctx context.Context) ApiBlockIomadCompanyAdminUnassignUsersRequest {
	return ApiBlockIomadCompanyAdminUnassignUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminUnassignUsersExecute(r ApiBlockIomadCompanyAdminUnassignUsersRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockIomadCompanyAdminAPIService.BlockIomadCompanyAdminUnassignUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block_iomad_company_admin_unassign_users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockIomadCompanyAdminUnassignUsersRequest == nil {
		return localVarReturnValue, nil, reportError("blockIomadCompanyAdminUnassignUsersRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blockIomadCompanyAdminUnassignUsersRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlockIomadCompanyAdminUpdateCoursesRequest struct {
	ctx context.Context
	ApiService *BlockIomadCompanyAdminAPIService
	blockIomadCompanyAdminUpdateCoursesRequest *BlockIomadCompanyAdminUpdateCoursesRequest
}

func (r ApiBlockIomadCompanyAdminUpdateCoursesRequest) BlockIomadCompanyAdminUpdateCoursesRequest(blockIomadCompanyAdminUpdateCoursesRequest BlockIomadCompanyAdminUpdateCoursesRequest) ApiBlockIomadCompanyAdminUpdateCoursesRequest {
	r.blockIomadCompanyAdminUpdateCoursesRequest = &blockIomadCompanyAdminUpdateCoursesRequest
	return r
}

func (r ApiBlockIomadCompanyAdminUpdateCoursesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.BlockIomadCompanyAdminUpdateCoursesExecute(r)
}

/*
BlockIomadCompanyAdminUpdateCourses Update Iomad course settings

Update Iomad course settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlockIomadCompanyAdminUpdateCoursesRequest
*/
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminUpdateCourses(ctx context.Context) ApiBlockIomadCompanyAdminUpdateCoursesRequest {
	return ApiBlockIomadCompanyAdminUpdateCoursesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BlockIomadCompanyAdminAPIService) BlockIomadCompanyAdminUpdateCoursesExecute(r ApiBlockIomadCompanyAdminUpdateCoursesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockIomadCompanyAdminAPIService.BlockIomadCompanyAdminUpdateCourses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block_iomad_company_admin_update_courses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockIomadCompanyAdminUpdateCoursesRequest == nil {
		return localVarReturnValue, nil, reportError("blockIomadCompanyAdminUpdateCoursesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blockIomadCompanyAdminUpdateCoursesRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
