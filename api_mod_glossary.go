/*
Moodle Webservice API

Auto-generated OpenAPI spec for Moodle's Webservice API. Requires installation of the Catalyst RESTful API plugin: https://github.com/catalyst/moodle-webservice_restful.

API version: 4.3.4
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package moodleclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// ModGlossaryAPIService ModGlossaryAPI service
type ModGlossaryAPIService service

type ApiModGlossaryAddEntryRequest struct {
	ctx context.Context
	ApiService *ModGlossaryAPIService
	modGlossaryAddEntryRequest *ModGlossaryAddEntryRequest
}

func (r ApiModGlossaryAddEntryRequest) ModGlossaryAddEntryRequest(modGlossaryAddEntryRequest ModGlossaryAddEntryRequest) ApiModGlossaryAddEntryRequest {
	r.modGlossaryAddEntryRequest = &modGlossaryAddEntryRequest
	return r
}

func (r ApiModGlossaryAddEntryRequest) Execute() (*ModGlossaryAddEntry200Response, *http.Response, error) {
	return r.ApiService.ModGlossaryAddEntryExecute(r)
}

/*
ModGlossaryAddEntry Add a new entry to a given glossary

Add a new entry to a given glossary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModGlossaryAddEntryRequest
*/
func (a *ModGlossaryAPIService) ModGlossaryAddEntry(ctx context.Context) ApiModGlossaryAddEntryRequest {
	return ApiModGlossaryAddEntryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModGlossaryAddEntry200Response
func (a *ModGlossaryAPIService) ModGlossaryAddEntryExecute(r ApiModGlossaryAddEntryRequest) (*ModGlossaryAddEntry200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModGlossaryAddEntry200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModGlossaryAPIService.ModGlossaryAddEntry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_glossary_add_entry"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modGlossaryAddEntryRequest == nil {
		return localVarReturnValue, nil, reportError("modGlossaryAddEntryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modGlossaryAddEntryRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModGlossaryDeleteEntryRequest struct {
	ctx context.Context
	ApiService *ModGlossaryAPIService
	modGlossaryDeleteEntryRequest *ModGlossaryDeleteEntryRequest
}

func (r ApiModGlossaryDeleteEntryRequest) ModGlossaryDeleteEntryRequest(modGlossaryDeleteEntryRequest ModGlossaryDeleteEntryRequest) ApiModGlossaryDeleteEntryRequest {
	r.modGlossaryDeleteEntryRequest = &modGlossaryDeleteEntryRequest
	return r
}

func (r ApiModGlossaryDeleteEntryRequest) Execute() (*CoreContentbankRenameContent200Response, *http.Response, error) {
	return r.ApiService.ModGlossaryDeleteEntryExecute(r)
}

/*
ModGlossaryDeleteEntry Delete the given entry from the glossary.

Delete the given entry from the glossary.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModGlossaryDeleteEntryRequest
*/
func (a *ModGlossaryAPIService) ModGlossaryDeleteEntry(ctx context.Context) ApiModGlossaryDeleteEntryRequest {
	return ApiModGlossaryDeleteEntryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreContentbankRenameContent200Response
func (a *ModGlossaryAPIService) ModGlossaryDeleteEntryExecute(r ApiModGlossaryDeleteEntryRequest) (*CoreContentbankRenameContent200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreContentbankRenameContent200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModGlossaryAPIService.ModGlossaryDeleteEntry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_glossary_delete_entry"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modGlossaryDeleteEntryRequest == nil {
		return localVarReturnValue, nil, reportError("modGlossaryDeleteEntryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modGlossaryDeleteEntryRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModGlossaryGetAuthorsRequest struct {
	ctx context.Context
	ApiService *ModGlossaryAPIService
	modGlossaryGetAuthorsRequest *ModGlossaryGetAuthorsRequest
}

func (r ApiModGlossaryGetAuthorsRequest) ModGlossaryGetAuthorsRequest(modGlossaryGetAuthorsRequest ModGlossaryGetAuthorsRequest) ApiModGlossaryGetAuthorsRequest {
	r.modGlossaryGetAuthorsRequest = &modGlossaryGetAuthorsRequest
	return r
}

func (r ApiModGlossaryGetAuthorsRequest) Execute() (*ModGlossaryGetAuthors200Response, *http.Response, error) {
	return r.ApiService.ModGlossaryGetAuthorsExecute(r)
}

/*
ModGlossaryGetAuthors Get the authors.

Get the authors.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModGlossaryGetAuthorsRequest
*/
func (a *ModGlossaryAPIService) ModGlossaryGetAuthors(ctx context.Context) ApiModGlossaryGetAuthorsRequest {
	return ApiModGlossaryGetAuthorsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModGlossaryGetAuthors200Response
func (a *ModGlossaryAPIService) ModGlossaryGetAuthorsExecute(r ApiModGlossaryGetAuthorsRequest) (*ModGlossaryGetAuthors200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModGlossaryGetAuthors200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModGlossaryAPIService.ModGlossaryGetAuthors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_glossary_get_authors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modGlossaryGetAuthorsRequest == nil {
		return localVarReturnValue, nil, reportError("modGlossaryGetAuthorsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modGlossaryGetAuthorsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModGlossaryGetCategoriesRequest struct {
	ctx context.Context
	ApiService *ModGlossaryAPIService
	modGlossaryGetCategoriesRequest *ModGlossaryGetCategoriesRequest
}

func (r ApiModGlossaryGetCategoriesRequest) ModGlossaryGetCategoriesRequest(modGlossaryGetCategoriesRequest ModGlossaryGetCategoriesRequest) ApiModGlossaryGetCategoriesRequest {
	r.modGlossaryGetCategoriesRequest = &modGlossaryGetCategoriesRequest
	return r
}

func (r ApiModGlossaryGetCategoriesRequest) Execute() (*ModGlossaryGetCategories200Response, *http.Response, error) {
	return r.ApiService.ModGlossaryGetCategoriesExecute(r)
}

/*
ModGlossaryGetCategories Get the categories.

Get the categories.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModGlossaryGetCategoriesRequest
*/
func (a *ModGlossaryAPIService) ModGlossaryGetCategories(ctx context.Context) ApiModGlossaryGetCategoriesRequest {
	return ApiModGlossaryGetCategoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModGlossaryGetCategories200Response
func (a *ModGlossaryAPIService) ModGlossaryGetCategoriesExecute(r ApiModGlossaryGetCategoriesRequest) (*ModGlossaryGetCategories200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModGlossaryGetCategories200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModGlossaryAPIService.ModGlossaryGetCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_glossary_get_categories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modGlossaryGetCategoriesRequest == nil {
		return localVarReturnValue, nil, reportError("modGlossaryGetCategoriesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modGlossaryGetCategoriesRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModGlossaryGetEntriesByAuthorRequest struct {
	ctx context.Context
	ApiService *ModGlossaryAPIService
	modGlossaryGetEntriesByAuthorRequest *ModGlossaryGetEntriesByAuthorRequest
}

func (r ApiModGlossaryGetEntriesByAuthorRequest) ModGlossaryGetEntriesByAuthorRequest(modGlossaryGetEntriesByAuthorRequest ModGlossaryGetEntriesByAuthorRequest) ApiModGlossaryGetEntriesByAuthorRequest {
	r.modGlossaryGetEntriesByAuthorRequest = &modGlossaryGetEntriesByAuthorRequest
	return r
}

func (r ApiModGlossaryGetEntriesByAuthorRequest) Execute() (*ModGlossaryGetEntriesByAuthor200Response, *http.Response, error) {
	return r.ApiService.ModGlossaryGetEntriesByAuthorExecute(r)
}

/*
ModGlossaryGetEntriesByAuthor Browse entries by author.

Browse entries by author.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModGlossaryGetEntriesByAuthorRequest
*/
func (a *ModGlossaryAPIService) ModGlossaryGetEntriesByAuthor(ctx context.Context) ApiModGlossaryGetEntriesByAuthorRequest {
	return ApiModGlossaryGetEntriesByAuthorRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModGlossaryGetEntriesByAuthor200Response
func (a *ModGlossaryAPIService) ModGlossaryGetEntriesByAuthorExecute(r ApiModGlossaryGetEntriesByAuthorRequest) (*ModGlossaryGetEntriesByAuthor200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModGlossaryGetEntriesByAuthor200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModGlossaryAPIService.ModGlossaryGetEntriesByAuthor")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_glossary_get_entries_by_author"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modGlossaryGetEntriesByAuthorRequest == nil {
		return localVarReturnValue, nil, reportError("modGlossaryGetEntriesByAuthorRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modGlossaryGetEntriesByAuthorRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModGlossaryGetEntriesByAuthorIdRequest struct {
	ctx context.Context
	ApiService *ModGlossaryAPIService
	modGlossaryGetEntriesByAuthorIdRequest *ModGlossaryGetEntriesByAuthorIdRequest
}

func (r ApiModGlossaryGetEntriesByAuthorIdRequest) ModGlossaryGetEntriesByAuthorIdRequest(modGlossaryGetEntriesByAuthorIdRequest ModGlossaryGetEntriesByAuthorIdRequest) ApiModGlossaryGetEntriesByAuthorIdRequest {
	r.modGlossaryGetEntriesByAuthorIdRequest = &modGlossaryGetEntriesByAuthorIdRequest
	return r
}

func (r ApiModGlossaryGetEntriesByAuthorIdRequest) Execute() (*ModGlossaryGetEntriesByAuthorId200Response, *http.Response, error) {
	return r.ApiService.ModGlossaryGetEntriesByAuthorIdExecute(r)
}

/*
ModGlossaryGetEntriesByAuthorId Browse entries by author ID.

Browse entries by author ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModGlossaryGetEntriesByAuthorIdRequest
*/
func (a *ModGlossaryAPIService) ModGlossaryGetEntriesByAuthorId(ctx context.Context) ApiModGlossaryGetEntriesByAuthorIdRequest {
	return ApiModGlossaryGetEntriesByAuthorIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModGlossaryGetEntriesByAuthorId200Response
func (a *ModGlossaryAPIService) ModGlossaryGetEntriesByAuthorIdExecute(r ApiModGlossaryGetEntriesByAuthorIdRequest) (*ModGlossaryGetEntriesByAuthorId200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModGlossaryGetEntriesByAuthorId200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModGlossaryAPIService.ModGlossaryGetEntriesByAuthorId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_glossary_get_entries_by_author_id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modGlossaryGetEntriesByAuthorIdRequest == nil {
		return localVarReturnValue, nil, reportError("modGlossaryGetEntriesByAuthorIdRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modGlossaryGetEntriesByAuthorIdRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModGlossaryGetEntriesByCategoryRequest struct {
	ctx context.Context
	ApiService *ModGlossaryAPIService
	modGlossaryGetEntriesByCategoryRequest *ModGlossaryGetEntriesByCategoryRequest
}

func (r ApiModGlossaryGetEntriesByCategoryRequest) ModGlossaryGetEntriesByCategoryRequest(modGlossaryGetEntriesByCategoryRequest ModGlossaryGetEntriesByCategoryRequest) ApiModGlossaryGetEntriesByCategoryRequest {
	r.modGlossaryGetEntriesByCategoryRequest = &modGlossaryGetEntriesByCategoryRequest
	return r
}

func (r ApiModGlossaryGetEntriesByCategoryRequest) Execute() (*ModGlossaryGetEntriesByCategory200Response, *http.Response, error) {
	return r.ApiService.ModGlossaryGetEntriesByCategoryExecute(r)
}

/*
ModGlossaryGetEntriesByCategory Browse entries by category.

Browse entries by category.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModGlossaryGetEntriesByCategoryRequest
*/
func (a *ModGlossaryAPIService) ModGlossaryGetEntriesByCategory(ctx context.Context) ApiModGlossaryGetEntriesByCategoryRequest {
	return ApiModGlossaryGetEntriesByCategoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModGlossaryGetEntriesByCategory200Response
func (a *ModGlossaryAPIService) ModGlossaryGetEntriesByCategoryExecute(r ApiModGlossaryGetEntriesByCategoryRequest) (*ModGlossaryGetEntriesByCategory200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModGlossaryGetEntriesByCategory200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModGlossaryAPIService.ModGlossaryGetEntriesByCategory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_glossary_get_entries_by_category"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modGlossaryGetEntriesByCategoryRequest == nil {
		return localVarReturnValue, nil, reportError("modGlossaryGetEntriesByCategoryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modGlossaryGetEntriesByCategoryRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModGlossaryGetEntriesByDateRequest struct {
	ctx context.Context
	ApiService *ModGlossaryAPIService
	modGlossaryGetEntriesByDateRequest *ModGlossaryGetEntriesByDateRequest
}

func (r ApiModGlossaryGetEntriesByDateRequest) ModGlossaryGetEntriesByDateRequest(modGlossaryGetEntriesByDateRequest ModGlossaryGetEntriesByDateRequest) ApiModGlossaryGetEntriesByDateRequest {
	r.modGlossaryGetEntriesByDateRequest = &modGlossaryGetEntriesByDateRequest
	return r
}

func (r ApiModGlossaryGetEntriesByDateRequest) Execute() (*ModGlossaryGetEntriesByAuthorId200Response, *http.Response, error) {
	return r.ApiService.ModGlossaryGetEntriesByDateExecute(r)
}

/*
ModGlossaryGetEntriesByDate Browse entries by date.

Browse entries by date.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModGlossaryGetEntriesByDateRequest
*/
func (a *ModGlossaryAPIService) ModGlossaryGetEntriesByDate(ctx context.Context) ApiModGlossaryGetEntriesByDateRequest {
	return ApiModGlossaryGetEntriesByDateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModGlossaryGetEntriesByAuthorId200Response
func (a *ModGlossaryAPIService) ModGlossaryGetEntriesByDateExecute(r ApiModGlossaryGetEntriesByDateRequest) (*ModGlossaryGetEntriesByAuthorId200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModGlossaryGetEntriesByAuthorId200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModGlossaryAPIService.ModGlossaryGetEntriesByDate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_glossary_get_entries_by_date"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modGlossaryGetEntriesByDateRequest == nil {
		return localVarReturnValue, nil, reportError("modGlossaryGetEntriesByDateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modGlossaryGetEntriesByDateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModGlossaryGetEntriesByLetterRequest struct {
	ctx context.Context
	ApiService *ModGlossaryAPIService
	modGlossaryGetEntriesByLetterRequest *ModGlossaryGetEntriesByLetterRequest
}

func (r ApiModGlossaryGetEntriesByLetterRequest) ModGlossaryGetEntriesByLetterRequest(modGlossaryGetEntriesByLetterRequest ModGlossaryGetEntriesByLetterRequest) ApiModGlossaryGetEntriesByLetterRequest {
	r.modGlossaryGetEntriesByLetterRequest = &modGlossaryGetEntriesByLetterRequest
	return r
}

func (r ApiModGlossaryGetEntriesByLetterRequest) Execute() (*ModGlossaryGetEntriesByAuthorId200Response, *http.Response, error) {
	return r.ApiService.ModGlossaryGetEntriesByLetterExecute(r)
}

/*
ModGlossaryGetEntriesByLetter Browse entries by letter.

Browse entries by letter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModGlossaryGetEntriesByLetterRequest
*/
func (a *ModGlossaryAPIService) ModGlossaryGetEntriesByLetter(ctx context.Context) ApiModGlossaryGetEntriesByLetterRequest {
	return ApiModGlossaryGetEntriesByLetterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModGlossaryGetEntriesByAuthorId200Response
func (a *ModGlossaryAPIService) ModGlossaryGetEntriesByLetterExecute(r ApiModGlossaryGetEntriesByLetterRequest) (*ModGlossaryGetEntriesByAuthorId200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModGlossaryGetEntriesByAuthorId200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModGlossaryAPIService.ModGlossaryGetEntriesByLetter")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_glossary_get_entries_by_letter"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modGlossaryGetEntriesByLetterRequest == nil {
		return localVarReturnValue, nil, reportError("modGlossaryGetEntriesByLetterRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modGlossaryGetEntriesByLetterRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModGlossaryGetEntriesBySearchRequest struct {
	ctx context.Context
	ApiService *ModGlossaryAPIService
	modGlossaryGetEntriesBySearchRequest *ModGlossaryGetEntriesBySearchRequest
}

func (r ApiModGlossaryGetEntriesBySearchRequest) ModGlossaryGetEntriesBySearchRequest(modGlossaryGetEntriesBySearchRequest ModGlossaryGetEntriesBySearchRequest) ApiModGlossaryGetEntriesBySearchRequest {
	r.modGlossaryGetEntriesBySearchRequest = &modGlossaryGetEntriesBySearchRequest
	return r
}

func (r ApiModGlossaryGetEntriesBySearchRequest) Execute() (*ModGlossaryGetEntriesByAuthorId200Response, *http.Response, error) {
	return r.ApiService.ModGlossaryGetEntriesBySearchExecute(r)
}

/*
ModGlossaryGetEntriesBySearch Browse entries by search query.

Browse entries by search query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModGlossaryGetEntriesBySearchRequest
*/
func (a *ModGlossaryAPIService) ModGlossaryGetEntriesBySearch(ctx context.Context) ApiModGlossaryGetEntriesBySearchRequest {
	return ApiModGlossaryGetEntriesBySearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModGlossaryGetEntriesByAuthorId200Response
func (a *ModGlossaryAPIService) ModGlossaryGetEntriesBySearchExecute(r ApiModGlossaryGetEntriesBySearchRequest) (*ModGlossaryGetEntriesByAuthorId200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModGlossaryGetEntriesByAuthorId200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModGlossaryAPIService.ModGlossaryGetEntriesBySearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_glossary_get_entries_by_search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modGlossaryGetEntriesBySearchRequest == nil {
		return localVarReturnValue, nil, reportError("modGlossaryGetEntriesBySearchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modGlossaryGetEntriesBySearchRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModGlossaryGetEntriesByTermRequest struct {
	ctx context.Context
	ApiService *ModGlossaryAPIService
	modGlossaryGetEntriesByTermRequest *ModGlossaryGetEntriesByTermRequest
}

func (r ApiModGlossaryGetEntriesByTermRequest) ModGlossaryGetEntriesByTermRequest(modGlossaryGetEntriesByTermRequest ModGlossaryGetEntriesByTermRequest) ApiModGlossaryGetEntriesByTermRequest {
	r.modGlossaryGetEntriesByTermRequest = &modGlossaryGetEntriesByTermRequest
	return r
}

func (r ApiModGlossaryGetEntriesByTermRequest) Execute() (*ModGlossaryGetEntriesByAuthorId200Response, *http.Response, error) {
	return r.ApiService.ModGlossaryGetEntriesByTermExecute(r)
}

/*
ModGlossaryGetEntriesByTerm Browse entries by term (concept or alias).

Browse entries by term (concept or alias).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModGlossaryGetEntriesByTermRequest
*/
func (a *ModGlossaryAPIService) ModGlossaryGetEntriesByTerm(ctx context.Context) ApiModGlossaryGetEntriesByTermRequest {
	return ApiModGlossaryGetEntriesByTermRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModGlossaryGetEntriesByAuthorId200Response
func (a *ModGlossaryAPIService) ModGlossaryGetEntriesByTermExecute(r ApiModGlossaryGetEntriesByTermRequest) (*ModGlossaryGetEntriesByAuthorId200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModGlossaryGetEntriesByAuthorId200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModGlossaryAPIService.ModGlossaryGetEntriesByTerm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_glossary_get_entries_by_term"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modGlossaryGetEntriesByTermRequest == nil {
		return localVarReturnValue, nil, reportError("modGlossaryGetEntriesByTermRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modGlossaryGetEntriesByTermRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModGlossaryGetEntriesToApproveRequest struct {
	ctx context.Context
	ApiService *ModGlossaryAPIService
	modGlossaryGetEntriesToApproveRequest *ModGlossaryGetEntriesToApproveRequest
}

func (r ApiModGlossaryGetEntriesToApproveRequest) ModGlossaryGetEntriesToApproveRequest(modGlossaryGetEntriesToApproveRequest ModGlossaryGetEntriesToApproveRequest) ApiModGlossaryGetEntriesToApproveRequest {
	r.modGlossaryGetEntriesToApproveRequest = &modGlossaryGetEntriesToApproveRequest
	return r
}

func (r ApiModGlossaryGetEntriesToApproveRequest) Execute() (*ModGlossaryGetEntriesByAuthorId200Response, *http.Response, error) {
	return r.ApiService.ModGlossaryGetEntriesToApproveExecute(r)
}

/*
ModGlossaryGetEntriesToApprove Browse entries to be approved.

Browse entries to be approved.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModGlossaryGetEntriesToApproveRequest
*/
func (a *ModGlossaryAPIService) ModGlossaryGetEntriesToApprove(ctx context.Context) ApiModGlossaryGetEntriesToApproveRequest {
	return ApiModGlossaryGetEntriesToApproveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModGlossaryGetEntriesByAuthorId200Response
func (a *ModGlossaryAPIService) ModGlossaryGetEntriesToApproveExecute(r ApiModGlossaryGetEntriesToApproveRequest) (*ModGlossaryGetEntriesByAuthorId200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModGlossaryGetEntriesByAuthorId200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModGlossaryAPIService.ModGlossaryGetEntriesToApprove")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_glossary_get_entries_to_approve"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modGlossaryGetEntriesToApproveRequest == nil {
		return localVarReturnValue, nil, reportError("modGlossaryGetEntriesToApproveRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modGlossaryGetEntriesToApproveRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModGlossaryGetEntryByIdRequest struct {
	ctx context.Context
	ApiService *ModGlossaryAPIService
	modGlossaryGetEntryByIdRequest *ModGlossaryGetEntryByIdRequest
}

func (r ApiModGlossaryGetEntryByIdRequest) ModGlossaryGetEntryByIdRequest(modGlossaryGetEntryByIdRequest ModGlossaryGetEntryByIdRequest) ApiModGlossaryGetEntryByIdRequest {
	r.modGlossaryGetEntryByIdRequest = &modGlossaryGetEntryByIdRequest
	return r
}

func (r ApiModGlossaryGetEntryByIdRequest) Execute() (*ModGlossaryGetEntryById200Response, *http.Response, error) {
	return r.ApiService.ModGlossaryGetEntryByIdExecute(r)
}

/*
ModGlossaryGetEntryById Get an entry by ID

Get an entry by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModGlossaryGetEntryByIdRequest
*/
func (a *ModGlossaryAPIService) ModGlossaryGetEntryById(ctx context.Context) ApiModGlossaryGetEntryByIdRequest {
	return ApiModGlossaryGetEntryByIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModGlossaryGetEntryById200Response
func (a *ModGlossaryAPIService) ModGlossaryGetEntryByIdExecute(r ApiModGlossaryGetEntryByIdRequest) (*ModGlossaryGetEntryById200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModGlossaryGetEntryById200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModGlossaryAPIService.ModGlossaryGetEntryById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_glossary_get_entry_by_id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modGlossaryGetEntryByIdRequest == nil {
		return localVarReturnValue, nil, reportError("modGlossaryGetEntryByIdRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modGlossaryGetEntryByIdRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModGlossaryGetGlossariesByCoursesRequest struct {
	ctx context.Context
	ApiService *ModGlossaryAPIService
	modChatGetChatsByCoursesRequest *ModChatGetChatsByCoursesRequest
}

func (r ApiModGlossaryGetGlossariesByCoursesRequest) ModChatGetChatsByCoursesRequest(modChatGetChatsByCoursesRequest ModChatGetChatsByCoursesRequest) ApiModGlossaryGetGlossariesByCoursesRequest {
	r.modChatGetChatsByCoursesRequest = &modChatGetChatsByCoursesRequest
	return r
}

func (r ApiModGlossaryGetGlossariesByCoursesRequest) Execute() (*ModGlossaryGetGlossariesByCourses200Response, *http.Response, error) {
	return r.ApiService.ModGlossaryGetGlossariesByCoursesExecute(r)
}

/*
ModGlossaryGetGlossariesByCourses Retrieve a list of glossaries from several courses.

Retrieve a list of glossaries from several courses.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModGlossaryGetGlossariesByCoursesRequest
*/
func (a *ModGlossaryAPIService) ModGlossaryGetGlossariesByCourses(ctx context.Context) ApiModGlossaryGetGlossariesByCoursesRequest {
	return ApiModGlossaryGetGlossariesByCoursesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModGlossaryGetGlossariesByCourses200Response
func (a *ModGlossaryAPIService) ModGlossaryGetGlossariesByCoursesExecute(r ApiModGlossaryGetGlossariesByCoursesRequest) (*ModGlossaryGetGlossariesByCourses200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModGlossaryGetGlossariesByCourses200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModGlossaryAPIService.ModGlossaryGetGlossariesByCourses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_glossary_get_glossaries_by_courses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modChatGetChatsByCoursesRequest == nil {
		return localVarReturnValue, nil, reportError("modChatGetChatsByCoursesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modChatGetChatsByCoursesRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModGlossaryPrepareEntryForEditionRequest struct {
	ctx context.Context
	ApiService *ModGlossaryAPIService
	modGlossaryPrepareEntryForEditionRequest *ModGlossaryPrepareEntryForEditionRequest
}

func (r ApiModGlossaryPrepareEntryForEditionRequest) ModGlossaryPrepareEntryForEditionRequest(modGlossaryPrepareEntryForEditionRequest ModGlossaryPrepareEntryForEditionRequest) ApiModGlossaryPrepareEntryForEditionRequest {
	r.modGlossaryPrepareEntryForEditionRequest = &modGlossaryPrepareEntryForEditionRequest
	return r
}

func (r ApiModGlossaryPrepareEntryForEditionRequest) Execute() (*ModGlossaryPrepareEntryForEdition200Response, *http.Response, error) {
	return r.ApiService.ModGlossaryPrepareEntryForEditionExecute(r)
}

/*
ModGlossaryPrepareEntryForEdition Prepares the given entry for edition returning draft item areas and file areas information.

Prepares the given entry for edition returning draft item areas and file areas information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModGlossaryPrepareEntryForEditionRequest
*/
func (a *ModGlossaryAPIService) ModGlossaryPrepareEntryForEdition(ctx context.Context) ApiModGlossaryPrepareEntryForEditionRequest {
	return ApiModGlossaryPrepareEntryForEditionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModGlossaryPrepareEntryForEdition200Response
func (a *ModGlossaryAPIService) ModGlossaryPrepareEntryForEditionExecute(r ApiModGlossaryPrepareEntryForEditionRequest) (*ModGlossaryPrepareEntryForEdition200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModGlossaryPrepareEntryForEdition200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModGlossaryAPIService.ModGlossaryPrepareEntryForEdition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_glossary_prepare_entry_for_edition"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modGlossaryPrepareEntryForEditionRequest == nil {
		return localVarReturnValue, nil, reportError("modGlossaryPrepareEntryForEditionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modGlossaryPrepareEntryForEditionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModGlossaryUpdateEntryRequest struct {
	ctx context.Context
	ApiService *ModGlossaryAPIService
	modGlossaryUpdateEntryRequest *ModGlossaryUpdateEntryRequest
}

func (r ApiModGlossaryUpdateEntryRequest) ModGlossaryUpdateEntryRequest(modGlossaryUpdateEntryRequest ModGlossaryUpdateEntryRequest) ApiModGlossaryUpdateEntryRequest {
	r.modGlossaryUpdateEntryRequest = &modGlossaryUpdateEntryRequest
	return r
}

func (r ApiModGlossaryUpdateEntryRequest) Execute() (*ModGlossaryUpdateEntry200Response, *http.Response, error) {
	return r.ApiService.ModGlossaryUpdateEntryExecute(r)
}

/*
ModGlossaryUpdateEntry Updates the given glossary entry.

Updates the given glossary entry.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModGlossaryUpdateEntryRequest
*/
func (a *ModGlossaryAPIService) ModGlossaryUpdateEntry(ctx context.Context) ApiModGlossaryUpdateEntryRequest {
	return ApiModGlossaryUpdateEntryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModGlossaryUpdateEntry200Response
func (a *ModGlossaryAPIService) ModGlossaryUpdateEntryExecute(r ApiModGlossaryUpdateEntryRequest) (*ModGlossaryUpdateEntry200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModGlossaryUpdateEntry200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModGlossaryAPIService.ModGlossaryUpdateEntry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_glossary_update_entry"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modGlossaryUpdateEntryRequest == nil {
		return localVarReturnValue, nil, reportError("modGlossaryUpdateEntryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modGlossaryUpdateEntryRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModGlossaryViewEntryRequest struct {
	ctx context.Context
	ApiService *ModGlossaryAPIService
	modGlossaryGetEntryByIdRequest *ModGlossaryGetEntryByIdRequest
}

func (r ApiModGlossaryViewEntryRequest) ModGlossaryGetEntryByIdRequest(modGlossaryGetEntryByIdRequest ModGlossaryGetEntryByIdRequest) ApiModGlossaryViewEntryRequest {
	r.modGlossaryGetEntryByIdRequest = &modGlossaryGetEntryByIdRequest
	return r
}

func (r ApiModGlossaryViewEntryRequest) Execute() (*ModGlossaryViewEntry200Response, *http.Response, error) {
	return r.ApiService.ModGlossaryViewEntryExecute(r)
}

/*
ModGlossaryViewEntry Notify a glossary entry as being viewed.

Notify a glossary entry as being viewed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModGlossaryViewEntryRequest
*/
func (a *ModGlossaryAPIService) ModGlossaryViewEntry(ctx context.Context) ApiModGlossaryViewEntryRequest {
	return ApiModGlossaryViewEntryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModGlossaryViewEntry200Response
func (a *ModGlossaryAPIService) ModGlossaryViewEntryExecute(r ApiModGlossaryViewEntryRequest) (*ModGlossaryViewEntry200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModGlossaryViewEntry200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModGlossaryAPIService.ModGlossaryViewEntry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_glossary_view_entry"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modGlossaryGetEntryByIdRequest == nil {
		return localVarReturnValue, nil, reportError("modGlossaryGetEntryByIdRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modGlossaryGetEntryByIdRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModGlossaryViewGlossaryRequest struct {
	ctx context.Context
	ApiService *ModGlossaryAPIService
	modGlossaryViewGlossaryRequest *ModGlossaryViewGlossaryRequest
}

func (r ApiModGlossaryViewGlossaryRequest) ModGlossaryViewGlossaryRequest(modGlossaryViewGlossaryRequest ModGlossaryViewGlossaryRequest) ApiModGlossaryViewGlossaryRequest {
	r.modGlossaryViewGlossaryRequest = &modGlossaryViewGlossaryRequest
	return r
}

func (r ApiModGlossaryViewGlossaryRequest) Execute() (*ModGlossaryViewGlossary200Response, *http.Response, error) {
	return r.ApiService.ModGlossaryViewGlossaryExecute(r)
}

/*
ModGlossaryViewGlossary Notify the glossary as being viewed.

Notify the glossary as being viewed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModGlossaryViewGlossaryRequest
*/
func (a *ModGlossaryAPIService) ModGlossaryViewGlossary(ctx context.Context) ApiModGlossaryViewGlossaryRequest {
	return ApiModGlossaryViewGlossaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModGlossaryViewGlossary200Response
func (a *ModGlossaryAPIService) ModGlossaryViewGlossaryExecute(r ApiModGlossaryViewGlossaryRequest) (*ModGlossaryViewGlossary200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModGlossaryViewGlossary200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModGlossaryAPIService.ModGlossaryViewGlossary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_glossary_view_glossary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modGlossaryViewGlossaryRequest == nil {
		return localVarReturnValue, nil, reportError("modGlossaryViewGlossaryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modGlossaryViewGlossaryRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
