/*
Moodle Webservice API

Auto-generated OpenAPI spec for Moodle's Webservice API. Requires installation of the Catalyst RESTful API plugin: https://github.com/catalyst/moodle-webservice_restful.

API version: 4.3.4
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package moodleclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// ModFeedbackAPIService ModFeedbackAPI service
type ModFeedbackAPIService service

type ApiModFeedbackGetAnalysisRequest struct {
	ctx context.Context
	ApiService *ModFeedbackAPIService
	modFeedbackGetAnalysisRequest *ModFeedbackGetAnalysisRequest
}

func (r ApiModFeedbackGetAnalysisRequest) ModFeedbackGetAnalysisRequest(modFeedbackGetAnalysisRequest ModFeedbackGetAnalysisRequest) ApiModFeedbackGetAnalysisRequest {
	r.modFeedbackGetAnalysisRequest = &modFeedbackGetAnalysisRequest
	return r
}

func (r ApiModFeedbackGetAnalysisRequest) Execute() (*ModFeedbackGetAnalysis200Response, *http.Response, error) {
	return r.ApiService.ModFeedbackGetAnalysisExecute(r)
}

/*
ModFeedbackGetAnalysis Retrieves the feedback analysis.

Retrieves the feedback analysis.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModFeedbackGetAnalysisRequest
*/
func (a *ModFeedbackAPIService) ModFeedbackGetAnalysis(ctx context.Context) ApiModFeedbackGetAnalysisRequest {
	return ApiModFeedbackGetAnalysisRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModFeedbackGetAnalysis200Response
func (a *ModFeedbackAPIService) ModFeedbackGetAnalysisExecute(r ApiModFeedbackGetAnalysisRequest) (*ModFeedbackGetAnalysis200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModFeedbackGetAnalysis200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModFeedbackAPIService.ModFeedbackGetAnalysis")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_feedback_get_analysis"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modFeedbackGetAnalysisRequest == nil {
		return localVarReturnValue, nil, reportError("modFeedbackGetAnalysisRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modFeedbackGetAnalysisRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModFeedbackGetCurrentCompletedTmpRequest struct {
	ctx context.Context
	ApiService *ModFeedbackAPIService
	modFeedbackGetCurrentCompletedTmpRequest *ModFeedbackGetCurrentCompletedTmpRequest
}

func (r ApiModFeedbackGetCurrentCompletedTmpRequest) ModFeedbackGetCurrentCompletedTmpRequest(modFeedbackGetCurrentCompletedTmpRequest ModFeedbackGetCurrentCompletedTmpRequest) ApiModFeedbackGetCurrentCompletedTmpRequest {
	r.modFeedbackGetCurrentCompletedTmpRequest = &modFeedbackGetCurrentCompletedTmpRequest
	return r
}

func (r ApiModFeedbackGetCurrentCompletedTmpRequest) Execute() (*ModFeedbackGetCurrentCompletedTmp200Response, *http.Response, error) {
	return r.ApiService.ModFeedbackGetCurrentCompletedTmpExecute(r)
}

/*
ModFeedbackGetCurrentCompletedTmp Returns the temporary completion record for the current user.

Returns the temporary completion record for the current user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModFeedbackGetCurrentCompletedTmpRequest
*/
func (a *ModFeedbackAPIService) ModFeedbackGetCurrentCompletedTmp(ctx context.Context) ApiModFeedbackGetCurrentCompletedTmpRequest {
	return ApiModFeedbackGetCurrentCompletedTmpRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModFeedbackGetCurrentCompletedTmp200Response
func (a *ModFeedbackAPIService) ModFeedbackGetCurrentCompletedTmpExecute(r ApiModFeedbackGetCurrentCompletedTmpRequest) (*ModFeedbackGetCurrentCompletedTmp200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModFeedbackGetCurrentCompletedTmp200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModFeedbackAPIService.ModFeedbackGetCurrentCompletedTmp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_feedback_get_current_completed_tmp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modFeedbackGetCurrentCompletedTmpRequest == nil {
		return localVarReturnValue, nil, reportError("modFeedbackGetCurrentCompletedTmpRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modFeedbackGetCurrentCompletedTmpRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModFeedbackGetFeedbackAccessInformationRequest struct {
	ctx context.Context
	ApiService *ModFeedbackAPIService
	modFeedbackGetFeedbackAccessInformationRequest *ModFeedbackGetFeedbackAccessInformationRequest
}

func (r ApiModFeedbackGetFeedbackAccessInformationRequest) ModFeedbackGetFeedbackAccessInformationRequest(modFeedbackGetFeedbackAccessInformationRequest ModFeedbackGetFeedbackAccessInformationRequest) ApiModFeedbackGetFeedbackAccessInformationRequest {
	r.modFeedbackGetFeedbackAccessInformationRequest = &modFeedbackGetFeedbackAccessInformationRequest
	return r
}

func (r ApiModFeedbackGetFeedbackAccessInformationRequest) Execute() (*ModFeedbackGetFeedbackAccessInformation200Response, *http.Response, error) {
	return r.ApiService.ModFeedbackGetFeedbackAccessInformationExecute(r)
}

/*
ModFeedbackGetFeedbackAccessInformation Return access information for a given feedback.

Return access information for a given feedback.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModFeedbackGetFeedbackAccessInformationRequest
*/
func (a *ModFeedbackAPIService) ModFeedbackGetFeedbackAccessInformation(ctx context.Context) ApiModFeedbackGetFeedbackAccessInformationRequest {
	return ApiModFeedbackGetFeedbackAccessInformationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModFeedbackGetFeedbackAccessInformation200Response
func (a *ModFeedbackAPIService) ModFeedbackGetFeedbackAccessInformationExecute(r ApiModFeedbackGetFeedbackAccessInformationRequest) (*ModFeedbackGetFeedbackAccessInformation200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModFeedbackGetFeedbackAccessInformation200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModFeedbackAPIService.ModFeedbackGetFeedbackAccessInformation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_feedback_get_feedback_access_information"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modFeedbackGetFeedbackAccessInformationRequest == nil {
		return localVarReturnValue, nil, reportError("modFeedbackGetFeedbackAccessInformationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modFeedbackGetFeedbackAccessInformationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModFeedbackGetFeedbacksByCoursesRequest struct {
	ctx context.Context
	ApiService *ModFeedbackAPIService
	modBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest *ModBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest
}

func (r ApiModFeedbackGetFeedbacksByCoursesRequest) ModBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest(modBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest ModBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest) ApiModFeedbackGetFeedbacksByCoursesRequest {
	r.modBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest = &modBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest
	return r
}

func (r ApiModFeedbackGetFeedbacksByCoursesRequest) Execute() (*ModFeedbackGetFeedbacksByCourses200Response, *http.Response, error) {
	return r.ApiService.ModFeedbackGetFeedbacksByCoursesExecute(r)
}

/*
ModFeedbackGetFeedbacksByCourses Returns a list of feedbacks in a provided list of courses, if no list is provided all feedbacks that                             the user can view will be returned.

Returns a list of feedbacks in a provided list of courses, if no list is provided all feedbacks that
                            the user can view will be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModFeedbackGetFeedbacksByCoursesRequest
*/
func (a *ModFeedbackAPIService) ModFeedbackGetFeedbacksByCourses(ctx context.Context) ApiModFeedbackGetFeedbacksByCoursesRequest {
	return ApiModFeedbackGetFeedbacksByCoursesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModFeedbackGetFeedbacksByCourses200Response
func (a *ModFeedbackAPIService) ModFeedbackGetFeedbacksByCoursesExecute(r ApiModFeedbackGetFeedbacksByCoursesRequest) (*ModFeedbackGetFeedbacksByCourses200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModFeedbackGetFeedbacksByCourses200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModFeedbackAPIService.ModFeedbackGetFeedbacksByCourses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_feedback_get_feedbacks_by_courses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest == nil {
		return localVarReturnValue, nil, reportError("modBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModFeedbackGetFinishedResponsesRequest struct {
	ctx context.Context
	ApiService *ModFeedbackAPIService
	modFeedbackGetFinishedResponsesRequest *ModFeedbackGetFinishedResponsesRequest
}

func (r ApiModFeedbackGetFinishedResponsesRequest) ModFeedbackGetFinishedResponsesRequest(modFeedbackGetFinishedResponsesRequest ModFeedbackGetFinishedResponsesRequest) ApiModFeedbackGetFinishedResponsesRequest {
	r.modFeedbackGetFinishedResponsesRequest = &modFeedbackGetFinishedResponsesRequest
	return r
}

func (r ApiModFeedbackGetFinishedResponsesRequest) Execute() (*ModFeedbackGetFinishedResponses200Response, *http.Response, error) {
	return r.ApiService.ModFeedbackGetFinishedResponsesExecute(r)
}

/*
ModFeedbackGetFinishedResponses Retrieves responses from the last finished attempt.

Retrieves responses from the last finished attempt.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModFeedbackGetFinishedResponsesRequest
*/
func (a *ModFeedbackAPIService) ModFeedbackGetFinishedResponses(ctx context.Context) ApiModFeedbackGetFinishedResponsesRequest {
	return ApiModFeedbackGetFinishedResponsesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModFeedbackGetFinishedResponses200Response
func (a *ModFeedbackAPIService) ModFeedbackGetFinishedResponsesExecute(r ApiModFeedbackGetFinishedResponsesRequest) (*ModFeedbackGetFinishedResponses200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModFeedbackGetFinishedResponses200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModFeedbackAPIService.ModFeedbackGetFinishedResponses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_feedback_get_finished_responses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modFeedbackGetFinishedResponsesRequest == nil {
		return localVarReturnValue, nil, reportError("modFeedbackGetFinishedResponsesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modFeedbackGetFinishedResponsesRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModFeedbackGetItemsRequest struct {
	ctx context.Context
	ApiService *ModFeedbackAPIService
	modFeedbackGetCurrentCompletedTmpRequest *ModFeedbackGetCurrentCompletedTmpRequest
}

func (r ApiModFeedbackGetItemsRequest) ModFeedbackGetCurrentCompletedTmpRequest(modFeedbackGetCurrentCompletedTmpRequest ModFeedbackGetCurrentCompletedTmpRequest) ApiModFeedbackGetItemsRequest {
	r.modFeedbackGetCurrentCompletedTmpRequest = &modFeedbackGetCurrentCompletedTmpRequest
	return r
}

func (r ApiModFeedbackGetItemsRequest) Execute() (*ModFeedbackGetItems200Response, *http.Response, error) {
	return r.ApiService.ModFeedbackGetItemsExecute(r)
}

/*
ModFeedbackGetItems Returns the items (questions) in the given feedback.

Returns the items (questions) in the given feedback.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModFeedbackGetItemsRequest
*/
func (a *ModFeedbackAPIService) ModFeedbackGetItems(ctx context.Context) ApiModFeedbackGetItemsRequest {
	return ApiModFeedbackGetItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModFeedbackGetItems200Response
func (a *ModFeedbackAPIService) ModFeedbackGetItemsExecute(r ApiModFeedbackGetItemsRequest) (*ModFeedbackGetItems200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModFeedbackGetItems200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModFeedbackAPIService.ModFeedbackGetItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_feedback_get_items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modFeedbackGetCurrentCompletedTmpRequest == nil {
		return localVarReturnValue, nil, reportError("modFeedbackGetCurrentCompletedTmpRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modFeedbackGetCurrentCompletedTmpRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModFeedbackGetLastCompletedRequest struct {
	ctx context.Context
	ApiService *ModFeedbackAPIService
	modFeedbackGetCurrentCompletedTmpRequest *ModFeedbackGetCurrentCompletedTmpRequest
}

func (r ApiModFeedbackGetLastCompletedRequest) ModFeedbackGetCurrentCompletedTmpRequest(modFeedbackGetCurrentCompletedTmpRequest ModFeedbackGetCurrentCompletedTmpRequest) ApiModFeedbackGetLastCompletedRequest {
	r.modFeedbackGetCurrentCompletedTmpRequest = &modFeedbackGetCurrentCompletedTmpRequest
	return r
}

func (r ApiModFeedbackGetLastCompletedRequest) Execute() (*ModFeedbackGetLastCompleted200Response, *http.Response, error) {
	return r.ApiService.ModFeedbackGetLastCompletedExecute(r)
}

/*
ModFeedbackGetLastCompleted Retrieves the last completion record for the current user.

Retrieves the last completion record for the current user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModFeedbackGetLastCompletedRequest
*/
func (a *ModFeedbackAPIService) ModFeedbackGetLastCompleted(ctx context.Context) ApiModFeedbackGetLastCompletedRequest {
	return ApiModFeedbackGetLastCompletedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModFeedbackGetLastCompleted200Response
func (a *ModFeedbackAPIService) ModFeedbackGetLastCompletedExecute(r ApiModFeedbackGetLastCompletedRequest) (*ModFeedbackGetLastCompleted200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModFeedbackGetLastCompleted200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModFeedbackAPIService.ModFeedbackGetLastCompleted")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_feedback_get_last_completed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modFeedbackGetCurrentCompletedTmpRequest == nil {
		return localVarReturnValue, nil, reportError("modFeedbackGetCurrentCompletedTmpRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modFeedbackGetCurrentCompletedTmpRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModFeedbackGetNonRespondentsRequest struct {
	ctx context.Context
	ApiService *ModFeedbackAPIService
	modFeedbackGetNonRespondentsRequest *ModFeedbackGetNonRespondentsRequest
}

func (r ApiModFeedbackGetNonRespondentsRequest) ModFeedbackGetNonRespondentsRequest(modFeedbackGetNonRespondentsRequest ModFeedbackGetNonRespondentsRequest) ApiModFeedbackGetNonRespondentsRequest {
	r.modFeedbackGetNonRespondentsRequest = &modFeedbackGetNonRespondentsRequest
	return r
}

func (r ApiModFeedbackGetNonRespondentsRequest) Execute() (*ModFeedbackGetNonRespondents200Response, *http.Response, error) {
	return r.ApiService.ModFeedbackGetNonRespondentsExecute(r)
}

/*
ModFeedbackGetNonRespondents Retrieves a list of students who didn't submit the feedback.

Retrieves a list of students who didn't submit the feedback.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModFeedbackGetNonRespondentsRequest
*/
func (a *ModFeedbackAPIService) ModFeedbackGetNonRespondents(ctx context.Context) ApiModFeedbackGetNonRespondentsRequest {
	return ApiModFeedbackGetNonRespondentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModFeedbackGetNonRespondents200Response
func (a *ModFeedbackAPIService) ModFeedbackGetNonRespondentsExecute(r ApiModFeedbackGetNonRespondentsRequest) (*ModFeedbackGetNonRespondents200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModFeedbackGetNonRespondents200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModFeedbackAPIService.ModFeedbackGetNonRespondents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_feedback_get_non_respondents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modFeedbackGetNonRespondentsRequest == nil {
		return localVarReturnValue, nil, reportError("modFeedbackGetNonRespondentsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modFeedbackGetNonRespondentsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModFeedbackGetPageItemsRequest struct {
	ctx context.Context
	ApiService *ModFeedbackAPIService
	modFeedbackGetPageItemsRequest *ModFeedbackGetPageItemsRequest
}

func (r ApiModFeedbackGetPageItemsRequest) ModFeedbackGetPageItemsRequest(modFeedbackGetPageItemsRequest ModFeedbackGetPageItemsRequest) ApiModFeedbackGetPageItemsRequest {
	r.modFeedbackGetPageItemsRequest = &modFeedbackGetPageItemsRequest
	return r
}

func (r ApiModFeedbackGetPageItemsRequest) Execute() (*ModFeedbackGetPageItems200Response, *http.Response, error) {
	return r.ApiService.ModFeedbackGetPageItemsExecute(r)
}

/*
ModFeedbackGetPageItems Get a single feedback page items.

Get a single feedback page items.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModFeedbackGetPageItemsRequest
*/
func (a *ModFeedbackAPIService) ModFeedbackGetPageItems(ctx context.Context) ApiModFeedbackGetPageItemsRequest {
	return ApiModFeedbackGetPageItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModFeedbackGetPageItems200Response
func (a *ModFeedbackAPIService) ModFeedbackGetPageItemsExecute(r ApiModFeedbackGetPageItemsRequest) (*ModFeedbackGetPageItems200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModFeedbackGetPageItems200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModFeedbackAPIService.ModFeedbackGetPageItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_feedback_get_page_items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modFeedbackGetPageItemsRequest == nil {
		return localVarReturnValue, nil, reportError("modFeedbackGetPageItemsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modFeedbackGetPageItemsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModFeedbackGetResponsesAnalysisRequest struct {
	ctx context.Context
	ApiService *ModFeedbackAPIService
	modFeedbackGetResponsesAnalysisRequest *ModFeedbackGetResponsesAnalysisRequest
}

func (r ApiModFeedbackGetResponsesAnalysisRequest) ModFeedbackGetResponsesAnalysisRequest(modFeedbackGetResponsesAnalysisRequest ModFeedbackGetResponsesAnalysisRequest) ApiModFeedbackGetResponsesAnalysisRequest {
	r.modFeedbackGetResponsesAnalysisRequest = &modFeedbackGetResponsesAnalysisRequest
	return r
}

func (r ApiModFeedbackGetResponsesAnalysisRequest) Execute() (*ModFeedbackGetResponsesAnalysis200Response, *http.Response, error) {
	return r.ApiService.ModFeedbackGetResponsesAnalysisExecute(r)
}

/*
ModFeedbackGetResponsesAnalysis Return the feedback user responses analysis.

Return the feedback user responses analysis.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModFeedbackGetResponsesAnalysisRequest
*/
func (a *ModFeedbackAPIService) ModFeedbackGetResponsesAnalysis(ctx context.Context) ApiModFeedbackGetResponsesAnalysisRequest {
	return ApiModFeedbackGetResponsesAnalysisRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModFeedbackGetResponsesAnalysis200Response
func (a *ModFeedbackAPIService) ModFeedbackGetResponsesAnalysisExecute(r ApiModFeedbackGetResponsesAnalysisRequest) (*ModFeedbackGetResponsesAnalysis200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModFeedbackGetResponsesAnalysis200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModFeedbackAPIService.ModFeedbackGetResponsesAnalysis")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_feedback_get_responses_analysis"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modFeedbackGetResponsesAnalysisRequest == nil {
		return localVarReturnValue, nil, reportError("modFeedbackGetResponsesAnalysisRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modFeedbackGetResponsesAnalysisRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModFeedbackGetUnfinishedResponsesRequest struct {
	ctx context.Context
	ApiService *ModFeedbackAPIService
	modFeedbackGetFinishedResponsesRequest *ModFeedbackGetFinishedResponsesRequest
}

func (r ApiModFeedbackGetUnfinishedResponsesRequest) ModFeedbackGetFinishedResponsesRequest(modFeedbackGetFinishedResponsesRequest ModFeedbackGetFinishedResponsesRequest) ApiModFeedbackGetUnfinishedResponsesRequest {
	r.modFeedbackGetFinishedResponsesRequest = &modFeedbackGetFinishedResponsesRequest
	return r
}

func (r ApiModFeedbackGetUnfinishedResponsesRequest) Execute() (*ModFeedbackGetUnfinishedResponses200Response, *http.Response, error) {
	return r.ApiService.ModFeedbackGetUnfinishedResponsesExecute(r)
}

/*
ModFeedbackGetUnfinishedResponses Retrieves responses from the current unfinished attempt.

Retrieves responses from the current unfinished attempt.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModFeedbackGetUnfinishedResponsesRequest
*/
func (a *ModFeedbackAPIService) ModFeedbackGetUnfinishedResponses(ctx context.Context) ApiModFeedbackGetUnfinishedResponsesRequest {
	return ApiModFeedbackGetUnfinishedResponsesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModFeedbackGetUnfinishedResponses200Response
func (a *ModFeedbackAPIService) ModFeedbackGetUnfinishedResponsesExecute(r ApiModFeedbackGetUnfinishedResponsesRequest) (*ModFeedbackGetUnfinishedResponses200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModFeedbackGetUnfinishedResponses200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModFeedbackAPIService.ModFeedbackGetUnfinishedResponses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_feedback_get_unfinished_responses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modFeedbackGetFinishedResponsesRequest == nil {
		return localVarReturnValue, nil, reportError("modFeedbackGetFinishedResponsesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modFeedbackGetFinishedResponsesRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModFeedbackLaunchFeedbackRequest struct {
	ctx context.Context
	ApiService *ModFeedbackAPIService
	modFeedbackGetCurrentCompletedTmpRequest *ModFeedbackGetCurrentCompletedTmpRequest
}

func (r ApiModFeedbackLaunchFeedbackRequest) ModFeedbackGetCurrentCompletedTmpRequest(modFeedbackGetCurrentCompletedTmpRequest ModFeedbackGetCurrentCompletedTmpRequest) ApiModFeedbackLaunchFeedbackRequest {
	r.modFeedbackGetCurrentCompletedTmpRequest = &modFeedbackGetCurrentCompletedTmpRequest
	return r
}

func (r ApiModFeedbackLaunchFeedbackRequest) Execute() (*ModFeedbackLaunchFeedback200Response, *http.Response, error) {
	return r.ApiService.ModFeedbackLaunchFeedbackExecute(r)
}

/*
ModFeedbackLaunchFeedback Starts or continues a feedback submission.

Starts or continues a feedback submission.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModFeedbackLaunchFeedbackRequest
*/
func (a *ModFeedbackAPIService) ModFeedbackLaunchFeedback(ctx context.Context) ApiModFeedbackLaunchFeedbackRequest {
	return ApiModFeedbackLaunchFeedbackRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModFeedbackLaunchFeedback200Response
func (a *ModFeedbackAPIService) ModFeedbackLaunchFeedbackExecute(r ApiModFeedbackLaunchFeedbackRequest) (*ModFeedbackLaunchFeedback200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModFeedbackLaunchFeedback200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModFeedbackAPIService.ModFeedbackLaunchFeedback")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_feedback_launch_feedback"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modFeedbackGetCurrentCompletedTmpRequest == nil {
		return localVarReturnValue, nil, reportError("modFeedbackGetCurrentCompletedTmpRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modFeedbackGetCurrentCompletedTmpRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModFeedbackProcessPageRequest struct {
	ctx context.Context
	ApiService *ModFeedbackAPIService
	modFeedbackProcessPageRequest *ModFeedbackProcessPageRequest
}

func (r ApiModFeedbackProcessPageRequest) ModFeedbackProcessPageRequest(modFeedbackProcessPageRequest ModFeedbackProcessPageRequest) ApiModFeedbackProcessPageRequest {
	r.modFeedbackProcessPageRequest = &modFeedbackProcessPageRequest
	return r
}

func (r ApiModFeedbackProcessPageRequest) Execute() (*ModFeedbackProcessPage200Response, *http.Response, error) {
	return r.ApiService.ModFeedbackProcessPageExecute(r)
}

/*
ModFeedbackProcessPage Process a jump between pages.

Process a jump between pages.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModFeedbackProcessPageRequest
*/
func (a *ModFeedbackAPIService) ModFeedbackProcessPage(ctx context.Context) ApiModFeedbackProcessPageRequest {
	return ApiModFeedbackProcessPageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModFeedbackProcessPage200Response
func (a *ModFeedbackAPIService) ModFeedbackProcessPageExecute(r ApiModFeedbackProcessPageRequest) (*ModFeedbackProcessPage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModFeedbackProcessPage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModFeedbackAPIService.ModFeedbackProcessPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_feedback_process_page"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modFeedbackProcessPageRequest == nil {
		return localVarReturnValue, nil, reportError("modFeedbackProcessPageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modFeedbackProcessPageRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModFeedbackViewFeedbackRequest struct {
	ctx context.Context
	ApiService *ModFeedbackAPIService
	modFeedbackViewFeedbackRequest *ModFeedbackViewFeedbackRequest
}

func (r ApiModFeedbackViewFeedbackRequest) ModFeedbackViewFeedbackRequest(modFeedbackViewFeedbackRequest ModFeedbackViewFeedbackRequest) ApiModFeedbackViewFeedbackRequest {
	r.modFeedbackViewFeedbackRequest = &modFeedbackViewFeedbackRequest
	return r
}

func (r ApiModFeedbackViewFeedbackRequest) Execute() (*CoreCalendarDeleteSubscription200Response, *http.Response, error) {
	return r.ApiService.ModFeedbackViewFeedbackExecute(r)
}

/*
ModFeedbackViewFeedback Trigger the course module viewed event and update the module completion status.

Trigger the course module viewed event and update the module completion status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModFeedbackViewFeedbackRequest
*/
func (a *ModFeedbackAPIService) ModFeedbackViewFeedback(ctx context.Context) ApiModFeedbackViewFeedbackRequest {
	return ApiModFeedbackViewFeedbackRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreCalendarDeleteSubscription200Response
func (a *ModFeedbackAPIService) ModFeedbackViewFeedbackExecute(r ApiModFeedbackViewFeedbackRequest) (*CoreCalendarDeleteSubscription200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreCalendarDeleteSubscription200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModFeedbackAPIService.ModFeedbackViewFeedback")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_feedback_view_feedback"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modFeedbackViewFeedbackRequest == nil {
		return localVarReturnValue, nil, reportError("modFeedbackViewFeedbackRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modFeedbackViewFeedbackRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
