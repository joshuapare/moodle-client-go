/*
Moodle Webservice API

Auto-generated OpenAPI spec for Moodle's Webservice API. Requires installation of the Catalyst RESTful API plugin: https://github.com/catalyst/moodle-webservice_restful.

API version: 4.3.4
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package moodleclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// ModWorkshopAPIService ModWorkshopAPI service
type ModWorkshopAPIService service

type ApiModWorkshopAddSubmissionRequest struct {
	ctx context.Context
	ApiService *ModWorkshopAPIService
	modWorkshopAddSubmissionRequest *ModWorkshopAddSubmissionRequest
}

func (r ApiModWorkshopAddSubmissionRequest) ModWorkshopAddSubmissionRequest(modWorkshopAddSubmissionRequest ModWorkshopAddSubmissionRequest) ApiModWorkshopAddSubmissionRequest {
	r.modWorkshopAddSubmissionRequest = &modWorkshopAddSubmissionRequest
	return r
}

func (r ApiModWorkshopAddSubmissionRequest) Execute() (*ModWorkshopAddSubmission200Response, *http.Response, error) {
	return r.ApiService.ModWorkshopAddSubmissionExecute(r)
}

/*
ModWorkshopAddSubmission Add a new submission to a given workshop.

Add a new submission to a given workshop.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModWorkshopAddSubmissionRequest
*/
func (a *ModWorkshopAPIService) ModWorkshopAddSubmission(ctx context.Context) ApiModWorkshopAddSubmissionRequest {
	return ApiModWorkshopAddSubmissionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModWorkshopAddSubmission200Response
func (a *ModWorkshopAPIService) ModWorkshopAddSubmissionExecute(r ApiModWorkshopAddSubmissionRequest) (*ModWorkshopAddSubmission200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModWorkshopAddSubmission200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModWorkshopAPIService.ModWorkshopAddSubmission")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_workshop_add_submission"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modWorkshopAddSubmissionRequest == nil {
		return localVarReturnValue, nil, reportError("modWorkshopAddSubmissionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modWorkshopAddSubmissionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModWorkshopDeleteSubmissionRequest struct {
	ctx context.Context
	ApiService *ModWorkshopAPIService
	modWorkshopDeleteSubmissionRequest *ModWorkshopDeleteSubmissionRequest
}

func (r ApiModWorkshopDeleteSubmissionRequest) ModWorkshopDeleteSubmissionRequest(modWorkshopDeleteSubmissionRequest ModWorkshopDeleteSubmissionRequest) ApiModWorkshopDeleteSubmissionRequest {
	r.modWorkshopDeleteSubmissionRequest = &modWorkshopDeleteSubmissionRequest
	return r
}

func (r ApiModWorkshopDeleteSubmissionRequest) Execute() (*ModWorkshopDeleteSubmission200Response, *http.Response, error) {
	return r.ApiService.ModWorkshopDeleteSubmissionExecute(r)
}

/*
ModWorkshopDeleteSubmission Deletes the given submission.

Deletes the given submission.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModWorkshopDeleteSubmissionRequest
*/
func (a *ModWorkshopAPIService) ModWorkshopDeleteSubmission(ctx context.Context) ApiModWorkshopDeleteSubmissionRequest {
	return ApiModWorkshopDeleteSubmissionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModWorkshopDeleteSubmission200Response
func (a *ModWorkshopAPIService) ModWorkshopDeleteSubmissionExecute(r ApiModWorkshopDeleteSubmissionRequest) (*ModWorkshopDeleteSubmission200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModWorkshopDeleteSubmission200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModWorkshopAPIService.ModWorkshopDeleteSubmission")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_workshop_delete_submission"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modWorkshopDeleteSubmissionRequest == nil {
		return localVarReturnValue, nil, reportError("modWorkshopDeleteSubmissionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modWorkshopDeleteSubmissionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModWorkshopEvaluateAssessmentRequest struct {
	ctx context.Context
	ApiService *ModWorkshopAPIService
	modWorkshopEvaluateAssessmentRequest *ModWorkshopEvaluateAssessmentRequest
}

func (r ApiModWorkshopEvaluateAssessmentRequest) ModWorkshopEvaluateAssessmentRequest(modWorkshopEvaluateAssessmentRequest ModWorkshopEvaluateAssessmentRequest) ApiModWorkshopEvaluateAssessmentRequest {
	r.modWorkshopEvaluateAssessmentRequest = &modWorkshopEvaluateAssessmentRequest
	return r
}

func (r ApiModWorkshopEvaluateAssessmentRequest) Execute() (*ModWorkshopEvaluateAssessment200Response, *http.Response, error) {
	return r.ApiService.ModWorkshopEvaluateAssessmentExecute(r)
}

/*
ModWorkshopEvaluateAssessment Evaluates an assessment (used by teachers for provide feedback to the reviewer).

Evaluates an assessment (used by teachers for provide feedback to the reviewer).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModWorkshopEvaluateAssessmentRequest
*/
func (a *ModWorkshopAPIService) ModWorkshopEvaluateAssessment(ctx context.Context) ApiModWorkshopEvaluateAssessmentRequest {
	return ApiModWorkshopEvaluateAssessmentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModWorkshopEvaluateAssessment200Response
func (a *ModWorkshopAPIService) ModWorkshopEvaluateAssessmentExecute(r ApiModWorkshopEvaluateAssessmentRequest) (*ModWorkshopEvaluateAssessment200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModWorkshopEvaluateAssessment200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModWorkshopAPIService.ModWorkshopEvaluateAssessment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_workshop_evaluate_assessment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modWorkshopEvaluateAssessmentRequest == nil {
		return localVarReturnValue, nil, reportError("modWorkshopEvaluateAssessmentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modWorkshopEvaluateAssessmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModWorkshopEvaluateSubmissionRequest struct {
	ctx context.Context
	ApiService *ModWorkshopAPIService
	modWorkshopEvaluateSubmissionRequest *ModWorkshopEvaluateSubmissionRequest
}

func (r ApiModWorkshopEvaluateSubmissionRequest) ModWorkshopEvaluateSubmissionRequest(modWorkshopEvaluateSubmissionRequest ModWorkshopEvaluateSubmissionRequest) ApiModWorkshopEvaluateSubmissionRequest {
	r.modWorkshopEvaluateSubmissionRequest = &modWorkshopEvaluateSubmissionRequest
	return r
}

func (r ApiModWorkshopEvaluateSubmissionRequest) Execute() (*ModWorkshopEvaluateSubmission200Response, *http.Response, error) {
	return r.ApiService.ModWorkshopEvaluateSubmissionExecute(r)
}

/*
ModWorkshopEvaluateSubmission Evaluates a submission (used by teachers for provide feedback or override the submission grade).

Evaluates a submission (used by teachers for provide feedback or override the submission grade).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModWorkshopEvaluateSubmissionRequest
*/
func (a *ModWorkshopAPIService) ModWorkshopEvaluateSubmission(ctx context.Context) ApiModWorkshopEvaluateSubmissionRequest {
	return ApiModWorkshopEvaluateSubmissionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModWorkshopEvaluateSubmission200Response
func (a *ModWorkshopAPIService) ModWorkshopEvaluateSubmissionExecute(r ApiModWorkshopEvaluateSubmissionRequest) (*ModWorkshopEvaluateSubmission200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModWorkshopEvaluateSubmission200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModWorkshopAPIService.ModWorkshopEvaluateSubmission")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_workshop_evaluate_submission"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modWorkshopEvaluateSubmissionRequest == nil {
		return localVarReturnValue, nil, reportError("modWorkshopEvaluateSubmissionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modWorkshopEvaluateSubmissionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModWorkshopGetAssessmentRequest struct {
	ctx context.Context
	ApiService *ModWorkshopAPIService
	modWorkshopGetAssessmentRequest *ModWorkshopGetAssessmentRequest
}

func (r ApiModWorkshopGetAssessmentRequest) ModWorkshopGetAssessmentRequest(modWorkshopGetAssessmentRequest ModWorkshopGetAssessmentRequest) ApiModWorkshopGetAssessmentRequest {
	r.modWorkshopGetAssessmentRequest = &modWorkshopGetAssessmentRequest
	return r
}

func (r ApiModWorkshopGetAssessmentRequest) Execute() (*ModWorkshopGetAssessment200Response, *http.Response, error) {
	return r.ApiService.ModWorkshopGetAssessmentExecute(r)
}

/*
ModWorkshopGetAssessment Retrieves the given assessment.

Retrieves the given assessment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModWorkshopGetAssessmentRequest
*/
func (a *ModWorkshopAPIService) ModWorkshopGetAssessment(ctx context.Context) ApiModWorkshopGetAssessmentRequest {
	return ApiModWorkshopGetAssessmentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModWorkshopGetAssessment200Response
func (a *ModWorkshopAPIService) ModWorkshopGetAssessmentExecute(r ApiModWorkshopGetAssessmentRequest) (*ModWorkshopGetAssessment200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModWorkshopGetAssessment200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModWorkshopAPIService.ModWorkshopGetAssessment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_workshop_get_assessment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modWorkshopGetAssessmentRequest == nil {
		return localVarReturnValue, nil, reportError("modWorkshopGetAssessmentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modWorkshopGetAssessmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModWorkshopGetAssessmentFormDefinitionRequest struct {
	ctx context.Context
	ApiService *ModWorkshopAPIService
	modWorkshopGetAssessmentFormDefinitionRequest *ModWorkshopGetAssessmentFormDefinitionRequest
}

func (r ApiModWorkshopGetAssessmentFormDefinitionRequest) ModWorkshopGetAssessmentFormDefinitionRequest(modWorkshopGetAssessmentFormDefinitionRequest ModWorkshopGetAssessmentFormDefinitionRequest) ApiModWorkshopGetAssessmentFormDefinitionRequest {
	r.modWorkshopGetAssessmentFormDefinitionRequest = &modWorkshopGetAssessmentFormDefinitionRequest
	return r
}

func (r ApiModWorkshopGetAssessmentFormDefinitionRequest) Execute() (*ModWorkshopGetAssessmentFormDefinition200Response, *http.Response, error) {
	return r.ApiService.ModWorkshopGetAssessmentFormDefinitionExecute(r)
}

/*
ModWorkshopGetAssessmentFormDefinition Retrieves the assessment form definition.

Retrieves the assessment form definition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModWorkshopGetAssessmentFormDefinitionRequest
*/
func (a *ModWorkshopAPIService) ModWorkshopGetAssessmentFormDefinition(ctx context.Context) ApiModWorkshopGetAssessmentFormDefinitionRequest {
	return ApiModWorkshopGetAssessmentFormDefinitionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModWorkshopGetAssessmentFormDefinition200Response
func (a *ModWorkshopAPIService) ModWorkshopGetAssessmentFormDefinitionExecute(r ApiModWorkshopGetAssessmentFormDefinitionRequest) (*ModWorkshopGetAssessmentFormDefinition200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModWorkshopGetAssessmentFormDefinition200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModWorkshopAPIService.ModWorkshopGetAssessmentFormDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_workshop_get_assessment_form_definition"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modWorkshopGetAssessmentFormDefinitionRequest == nil {
		return localVarReturnValue, nil, reportError("modWorkshopGetAssessmentFormDefinitionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modWorkshopGetAssessmentFormDefinitionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModWorkshopGetGradesRequest struct {
	ctx context.Context
	ApiService *ModWorkshopAPIService
	modWorkshopGetGradesRequest *ModWorkshopGetGradesRequest
}

func (r ApiModWorkshopGetGradesRequest) ModWorkshopGetGradesRequest(modWorkshopGetGradesRequest ModWorkshopGetGradesRequest) ApiModWorkshopGetGradesRequest {
	r.modWorkshopGetGradesRequest = &modWorkshopGetGradesRequest
	return r
}

func (r ApiModWorkshopGetGradesRequest) Execute() (*ModWorkshopGetGrades200Response, *http.Response, error) {
	return r.ApiService.ModWorkshopGetGradesExecute(r)
}

/*
ModWorkshopGetGrades Returns the assessment and submission grade for the given user.

Returns the assessment and submission grade for the given user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModWorkshopGetGradesRequest
*/
func (a *ModWorkshopAPIService) ModWorkshopGetGrades(ctx context.Context) ApiModWorkshopGetGradesRequest {
	return ApiModWorkshopGetGradesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModWorkshopGetGrades200Response
func (a *ModWorkshopAPIService) ModWorkshopGetGradesExecute(r ApiModWorkshopGetGradesRequest) (*ModWorkshopGetGrades200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModWorkshopGetGrades200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModWorkshopAPIService.ModWorkshopGetGrades")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_workshop_get_grades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modWorkshopGetGradesRequest == nil {
		return localVarReturnValue, nil, reportError("modWorkshopGetGradesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modWorkshopGetGradesRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModWorkshopGetGradesReportRequest struct {
	ctx context.Context
	ApiService *ModWorkshopAPIService
	modWorkshopGetGradesReportRequest *ModWorkshopGetGradesReportRequest
}

func (r ApiModWorkshopGetGradesReportRequest) ModWorkshopGetGradesReportRequest(modWorkshopGetGradesReportRequest ModWorkshopGetGradesReportRequest) ApiModWorkshopGetGradesReportRequest {
	r.modWorkshopGetGradesReportRequest = &modWorkshopGetGradesReportRequest
	return r
}

func (r ApiModWorkshopGetGradesReportRequest) Execute() (*ModWorkshopGetGradesReport200Response, *http.Response, error) {
	return r.ApiService.ModWorkshopGetGradesReportExecute(r)
}

/*
ModWorkshopGetGradesReport Retrieves the assessment grades report.

Retrieves the assessment grades report.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModWorkshopGetGradesReportRequest
*/
func (a *ModWorkshopAPIService) ModWorkshopGetGradesReport(ctx context.Context) ApiModWorkshopGetGradesReportRequest {
	return ApiModWorkshopGetGradesReportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModWorkshopGetGradesReport200Response
func (a *ModWorkshopAPIService) ModWorkshopGetGradesReportExecute(r ApiModWorkshopGetGradesReportRequest) (*ModWorkshopGetGradesReport200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModWorkshopGetGradesReport200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModWorkshopAPIService.ModWorkshopGetGradesReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_workshop_get_grades_report"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modWorkshopGetGradesReportRequest == nil {
		return localVarReturnValue, nil, reportError("modWorkshopGetGradesReportRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modWorkshopGetGradesReportRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModWorkshopGetReviewerAssessmentsRequest struct {
	ctx context.Context
	ApiService *ModWorkshopAPIService
	modWorkshopGetReviewerAssessmentsRequest *ModWorkshopGetReviewerAssessmentsRequest
}

func (r ApiModWorkshopGetReviewerAssessmentsRequest) ModWorkshopGetReviewerAssessmentsRequest(modWorkshopGetReviewerAssessmentsRequest ModWorkshopGetReviewerAssessmentsRequest) ApiModWorkshopGetReviewerAssessmentsRequest {
	r.modWorkshopGetReviewerAssessmentsRequest = &modWorkshopGetReviewerAssessmentsRequest
	return r
}

func (r ApiModWorkshopGetReviewerAssessmentsRequest) Execute() (*ModWorkshopGetReviewerAssessments200Response, *http.Response, error) {
	return r.ApiService.ModWorkshopGetReviewerAssessmentsExecute(r)
}

/*
ModWorkshopGetReviewerAssessments Retrieves all the assessments reviewed by the given user.

Retrieves all the assessments reviewed by the given user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModWorkshopGetReviewerAssessmentsRequest
*/
func (a *ModWorkshopAPIService) ModWorkshopGetReviewerAssessments(ctx context.Context) ApiModWorkshopGetReviewerAssessmentsRequest {
	return ApiModWorkshopGetReviewerAssessmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModWorkshopGetReviewerAssessments200Response
func (a *ModWorkshopAPIService) ModWorkshopGetReviewerAssessmentsExecute(r ApiModWorkshopGetReviewerAssessmentsRequest) (*ModWorkshopGetReviewerAssessments200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModWorkshopGetReviewerAssessments200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModWorkshopAPIService.ModWorkshopGetReviewerAssessments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_workshop_get_reviewer_assessments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modWorkshopGetReviewerAssessmentsRequest == nil {
		return localVarReturnValue, nil, reportError("modWorkshopGetReviewerAssessmentsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modWorkshopGetReviewerAssessmentsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModWorkshopGetSubmissionRequest struct {
	ctx context.Context
	ApiService *ModWorkshopAPIService
	modWorkshopGetSubmissionRequest *ModWorkshopGetSubmissionRequest
}

func (r ApiModWorkshopGetSubmissionRequest) ModWorkshopGetSubmissionRequest(modWorkshopGetSubmissionRequest ModWorkshopGetSubmissionRequest) ApiModWorkshopGetSubmissionRequest {
	r.modWorkshopGetSubmissionRequest = &modWorkshopGetSubmissionRequest
	return r
}

func (r ApiModWorkshopGetSubmissionRequest) Execute() (*ModWorkshopGetSubmission200Response, *http.Response, error) {
	return r.ApiService.ModWorkshopGetSubmissionExecute(r)
}

/*
ModWorkshopGetSubmission Retrieves the given submission.

Retrieves the given submission.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModWorkshopGetSubmissionRequest
*/
func (a *ModWorkshopAPIService) ModWorkshopGetSubmission(ctx context.Context) ApiModWorkshopGetSubmissionRequest {
	return ApiModWorkshopGetSubmissionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModWorkshopGetSubmission200Response
func (a *ModWorkshopAPIService) ModWorkshopGetSubmissionExecute(r ApiModWorkshopGetSubmissionRequest) (*ModWorkshopGetSubmission200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModWorkshopGetSubmission200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModWorkshopAPIService.ModWorkshopGetSubmission")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_workshop_get_submission"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modWorkshopGetSubmissionRequest == nil {
		return localVarReturnValue, nil, reportError("modWorkshopGetSubmissionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modWorkshopGetSubmissionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModWorkshopGetSubmissionAssessmentsRequest struct {
	ctx context.Context
	ApiService *ModWorkshopAPIService
	modWorkshopGetSubmissionRequest *ModWorkshopGetSubmissionRequest
}

func (r ApiModWorkshopGetSubmissionAssessmentsRequest) ModWorkshopGetSubmissionRequest(modWorkshopGetSubmissionRequest ModWorkshopGetSubmissionRequest) ApiModWorkshopGetSubmissionAssessmentsRequest {
	r.modWorkshopGetSubmissionRequest = &modWorkshopGetSubmissionRequest
	return r
}

func (r ApiModWorkshopGetSubmissionAssessmentsRequest) Execute() (*ModWorkshopGetReviewerAssessments200Response, *http.Response, error) {
	return r.ApiService.ModWorkshopGetSubmissionAssessmentsExecute(r)
}

/*
ModWorkshopGetSubmissionAssessments Retrieves all the assessments of the given submission.

Retrieves all the assessments of the given submission.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModWorkshopGetSubmissionAssessmentsRequest
*/
func (a *ModWorkshopAPIService) ModWorkshopGetSubmissionAssessments(ctx context.Context) ApiModWorkshopGetSubmissionAssessmentsRequest {
	return ApiModWorkshopGetSubmissionAssessmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModWorkshopGetReviewerAssessments200Response
func (a *ModWorkshopAPIService) ModWorkshopGetSubmissionAssessmentsExecute(r ApiModWorkshopGetSubmissionAssessmentsRequest) (*ModWorkshopGetReviewerAssessments200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModWorkshopGetReviewerAssessments200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModWorkshopAPIService.ModWorkshopGetSubmissionAssessments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_workshop_get_submission_assessments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modWorkshopGetSubmissionRequest == nil {
		return localVarReturnValue, nil, reportError("modWorkshopGetSubmissionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modWorkshopGetSubmissionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModWorkshopGetSubmissionsRequest struct {
	ctx context.Context
	ApiService *ModWorkshopAPIService
	modWorkshopGetSubmissionsRequest *ModWorkshopGetSubmissionsRequest
}

func (r ApiModWorkshopGetSubmissionsRequest) ModWorkshopGetSubmissionsRequest(modWorkshopGetSubmissionsRequest ModWorkshopGetSubmissionsRequest) ApiModWorkshopGetSubmissionsRequest {
	r.modWorkshopGetSubmissionsRequest = &modWorkshopGetSubmissionsRequest
	return r
}

func (r ApiModWorkshopGetSubmissionsRequest) Execute() (*ModWorkshopGetSubmissions200Response, *http.Response, error) {
	return r.ApiService.ModWorkshopGetSubmissionsExecute(r)
}

/*
ModWorkshopGetSubmissions Retrieves all the workshop submissions or the one done by the given user (except example submissions).

Retrieves all the workshop submissions or the one done by the given user (except example submissions).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModWorkshopGetSubmissionsRequest
*/
func (a *ModWorkshopAPIService) ModWorkshopGetSubmissions(ctx context.Context) ApiModWorkshopGetSubmissionsRequest {
	return ApiModWorkshopGetSubmissionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModWorkshopGetSubmissions200Response
func (a *ModWorkshopAPIService) ModWorkshopGetSubmissionsExecute(r ApiModWorkshopGetSubmissionsRequest) (*ModWorkshopGetSubmissions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModWorkshopGetSubmissions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModWorkshopAPIService.ModWorkshopGetSubmissions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_workshop_get_submissions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modWorkshopGetSubmissionsRequest == nil {
		return localVarReturnValue, nil, reportError("modWorkshopGetSubmissionsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modWorkshopGetSubmissionsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModWorkshopGetUserPlanRequest struct {
	ctx context.Context
	ApiService *ModWorkshopAPIService
	modWorkshopGetUserPlanRequest *ModWorkshopGetUserPlanRequest
}

func (r ApiModWorkshopGetUserPlanRequest) ModWorkshopGetUserPlanRequest(modWorkshopGetUserPlanRequest ModWorkshopGetUserPlanRequest) ApiModWorkshopGetUserPlanRequest {
	r.modWorkshopGetUserPlanRequest = &modWorkshopGetUserPlanRequest
	return r
}

func (r ApiModWorkshopGetUserPlanRequest) Execute() (*ModWorkshopGetUserPlan200Response, *http.Response, error) {
	return r.ApiService.ModWorkshopGetUserPlanExecute(r)
}

/*
ModWorkshopGetUserPlan Return the planner information for the given user.

Return the planner information for the given user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModWorkshopGetUserPlanRequest
*/
func (a *ModWorkshopAPIService) ModWorkshopGetUserPlan(ctx context.Context) ApiModWorkshopGetUserPlanRequest {
	return ApiModWorkshopGetUserPlanRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModWorkshopGetUserPlan200Response
func (a *ModWorkshopAPIService) ModWorkshopGetUserPlanExecute(r ApiModWorkshopGetUserPlanRequest) (*ModWorkshopGetUserPlan200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModWorkshopGetUserPlan200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModWorkshopAPIService.ModWorkshopGetUserPlan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_workshop_get_user_plan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modWorkshopGetUserPlanRequest == nil {
		return localVarReturnValue, nil, reportError("modWorkshopGetUserPlanRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modWorkshopGetUserPlanRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModWorkshopGetWorkshopAccessInformationRequest struct {
	ctx context.Context
	ApiService *ModWorkshopAPIService
	modWorkshopGetWorkshopAccessInformationRequest *ModWorkshopGetWorkshopAccessInformationRequest
}

func (r ApiModWorkshopGetWorkshopAccessInformationRequest) ModWorkshopGetWorkshopAccessInformationRequest(modWorkshopGetWorkshopAccessInformationRequest ModWorkshopGetWorkshopAccessInformationRequest) ApiModWorkshopGetWorkshopAccessInformationRequest {
	r.modWorkshopGetWorkshopAccessInformationRequest = &modWorkshopGetWorkshopAccessInformationRequest
	return r
}

func (r ApiModWorkshopGetWorkshopAccessInformationRequest) Execute() (*ModWorkshopGetWorkshopAccessInformation200Response, *http.Response, error) {
	return r.ApiService.ModWorkshopGetWorkshopAccessInformationExecute(r)
}

/*
ModWorkshopGetWorkshopAccessInformation Return access information for a given workshop.

Return access information for a given workshop.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModWorkshopGetWorkshopAccessInformationRequest
*/
func (a *ModWorkshopAPIService) ModWorkshopGetWorkshopAccessInformation(ctx context.Context) ApiModWorkshopGetWorkshopAccessInformationRequest {
	return ApiModWorkshopGetWorkshopAccessInformationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModWorkshopGetWorkshopAccessInformation200Response
func (a *ModWorkshopAPIService) ModWorkshopGetWorkshopAccessInformationExecute(r ApiModWorkshopGetWorkshopAccessInformationRequest) (*ModWorkshopGetWorkshopAccessInformation200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModWorkshopGetWorkshopAccessInformation200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModWorkshopAPIService.ModWorkshopGetWorkshopAccessInformation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_workshop_get_workshop_access_information"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modWorkshopGetWorkshopAccessInformationRequest == nil {
		return localVarReturnValue, nil, reportError("modWorkshopGetWorkshopAccessInformationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modWorkshopGetWorkshopAccessInformationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModWorkshopGetWorkshopsByCoursesRequest struct {
	ctx context.Context
	ApiService *ModWorkshopAPIService
	modBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest *ModBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest
}

func (r ApiModWorkshopGetWorkshopsByCoursesRequest) ModBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest(modBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest ModBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest) ApiModWorkshopGetWorkshopsByCoursesRequest {
	r.modBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest = &modBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest
	return r
}

func (r ApiModWorkshopGetWorkshopsByCoursesRequest) Execute() (*ModWorkshopGetWorkshopsByCourses200Response, *http.Response, error) {
	return r.ApiService.ModWorkshopGetWorkshopsByCoursesExecute(r)
}

/*
ModWorkshopGetWorkshopsByCourses Returns a list of workshops in a provided list of courses, if no list is provided all workshops that                             the user can view will be returned.

Returns a list of workshops in a provided list of courses, if no list is provided all workshops that
                            the user can view will be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModWorkshopGetWorkshopsByCoursesRequest
*/
func (a *ModWorkshopAPIService) ModWorkshopGetWorkshopsByCourses(ctx context.Context) ApiModWorkshopGetWorkshopsByCoursesRequest {
	return ApiModWorkshopGetWorkshopsByCoursesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModWorkshopGetWorkshopsByCourses200Response
func (a *ModWorkshopAPIService) ModWorkshopGetWorkshopsByCoursesExecute(r ApiModWorkshopGetWorkshopsByCoursesRequest) (*ModWorkshopGetWorkshopsByCourses200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModWorkshopGetWorkshopsByCourses200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModWorkshopAPIService.ModWorkshopGetWorkshopsByCourses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_workshop_get_workshops_by_courses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest == nil {
		return localVarReturnValue, nil, reportError("modBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModWorkshopUpdateAssessmentRequest struct {
	ctx context.Context
	ApiService *ModWorkshopAPIService
	modWorkshopUpdateAssessmentRequest *ModWorkshopUpdateAssessmentRequest
}

func (r ApiModWorkshopUpdateAssessmentRequest) ModWorkshopUpdateAssessmentRequest(modWorkshopUpdateAssessmentRequest ModWorkshopUpdateAssessmentRequest) ApiModWorkshopUpdateAssessmentRequest {
	r.modWorkshopUpdateAssessmentRequest = &modWorkshopUpdateAssessmentRequest
	return r
}

func (r ApiModWorkshopUpdateAssessmentRequest) Execute() (*ModWorkshopUpdateAssessment200Response, *http.Response, error) {
	return r.ApiService.ModWorkshopUpdateAssessmentExecute(r)
}

/*
ModWorkshopUpdateAssessment Add information to an allocated assessment.

Add information to an allocated assessment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModWorkshopUpdateAssessmentRequest
*/
func (a *ModWorkshopAPIService) ModWorkshopUpdateAssessment(ctx context.Context) ApiModWorkshopUpdateAssessmentRequest {
	return ApiModWorkshopUpdateAssessmentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModWorkshopUpdateAssessment200Response
func (a *ModWorkshopAPIService) ModWorkshopUpdateAssessmentExecute(r ApiModWorkshopUpdateAssessmentRequest) (*ModWorkshopUpdateAssessment200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModWorkshopUpdateAssessment200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModWorkshopAPIService.ModWorkshopUpdateAssessment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_workshop_update_assessment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modWorkshopUpdateAssessmentRequest == nil {
		return localVarReturnValue, nil, reportError("modWorkshopUpdateAssessmentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modWorkshopUpdateAssessmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModWorkshopUpdateSubmissionRequest struct {
	ctx context.Context
	ApiService *ModWorkshopAPIService
	modWorkshopUpdateSubmissionRequest *ModWorkshopUpdateSubmissionRequest
}

func (r ApiModWorkshopUpdateSubmissionRequest) ModWorkshopUpdateSubmissionRequest(modWorkshopUpdateSubmissionRequest ModWorkshopUpdateSubmissionRequest) ApiModWorkshopUpdateSubmissionRequest {
	r.modWorkshopUpdateSubmissionRequest = &modWorkshopUpdateSubmissionRequest
	return r
}

func (r ApiModWorkshopUpdateSubmissionRequest) Execute() (*ModWorkshopUpdateSubmission200Response, *http.Response, error) {
	return r.ApiService.ModWorkshopUpdateSubmissionExecute(r)
}

/*
ModWorkshopUpdateSubmission Update the given submission.

Update the given submission.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModWorkshopUpdateSubmissionRequest
*/
func (a *ModWorkshopAPIService) ModWorkshopUpdateSubmission(ctx context.Context) ApiModWorkshopUpdateSubmissionRequest {
	return ApiModWorkshopUpdateSubmissionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModWorkshopUpdateSubmission200Response
func (a *ModWorkshopAPIService) ModWorkshopUpdateSubmissionExecute(r ApiModWorkshopUpdateSubmissionRequest) (*ModWorkshopUpdateSubmission200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModWorkshopUpdateSubmission200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModWorkshopAPIService.ModWorkshopUpdateSubmission")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_workshop_update_submission"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modWorkshopUpdateSubmissionRequest == nil {
		return localVarReturnValue, nil, reportError("modWorkshopUpdateSubmissionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modWorkshopUpdateSubmissionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModWorkshopViewSubmissionRequest struct {
	ctx context.Context
	ApiService *ModWorkshopAPIService
	modWorkshopGetSubmissionRequest *ModWorkshopGetSubmissionRequest
}

func (r ApiModWorkshopViewSubmissionRequest) ModWorkshopGetSubmissionRequest(modWorkshopGetSubmissionRequest ModWorkshopGetSubmissionRequest) ApiModWorkshopViewSubmissionRequest {
	r.modWorkshopGetSubmissionRequest = &modWorkshopGetSubmissionRequest
	return r
}

func (r ApiModWorkshopViewSubmissionRequest) Execute() (*CoreCalendarDeleteSubscription200Response, *http.Response, error) {
	return r.ApiService.ModWorkshopViewSubmissionExecute(r)
}

/*
ModWorkshopViewSubmission Trigger the submission viewed event.

Trigger the submission viewed event.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModWorkshopViewSubmissionRequest
*/
func (a *ModWorkshopAPIService) ModWorkshopViewSubmission(ctx context.Context) ApiModWorkshopViewSubmissionRequest {
	return ApiModWorkshopViewSubmissionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreCalendarDeleteSubscription200Response
func (a *ModWorkshopAPIService) ModWorkshopViewSubmissionExecute(r ApiModWorkshopViewSubmissionRequest) (*CoreCalendarDeleteSubscription200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreCalendarDeleteSubscription200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModWorkshopAPIService.ModWorkshopViewSubmission")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_workshop_view_submission"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modWorkshopGetSubmissionRequest == nil {
		return localVarReturnValue, nil, reportError("modWorkshopGetSubmissionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modWorkshopGetSubmissionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModWorkshopViewWorkshopRequest struct {
	ctx context.Context
	ApiService *ModWorkshopAPIService
	modWorkshopViewWorkshopRequest *ModWorkshopViewWorkshopRequest
}

func (r ApiModWorkshopViewWorkshopRequest) ModWorkshopViewWorkshopRequest(modWorkshopViewWorkshopRequest ModWorkshopViewWorkshopRequest) ApiModWorkshopViewWorkshopRequest {
	r.modWorkshopViewWorkshopRequest = &modWorkshopViewWorkshopRequest
	return r
}

func (r ApiModWorkshopViewWorkshopRequest) Execute() (*CoreCalendarDeleteSubscription200Response, *http.Response, error) {
	return r.ApiService.ModWorkshopViewWorkshopExecute(r)
}

/*
ModWorkshopViewWorkshop Trigger the course module viewed event and update the module completion status.

Trigger the course module viewed event and update the module completion status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModWorkshopViewWorkshopRequest
*/
func (a *ModWorkshopAPIService) ModWorkshopViewWorkshop(ctx context.Context) ApiModWorkshopViewWorkshopRequest {
	return ApiModWorkshopViewWorkshopRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreCalendarDeleteSubscription200Response
func (a *ModWorkshopAPIService) ModWorkshopViewWorkshopExecute(r ApiModWorkshopViewWorkshopRequest) (*CoreCalendarDeleteSubscription200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreCalendarDeleteSubscription200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModWorkshopAPIService.ModWorkshopViewWorkshop")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_workshop_view_workshop"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modWorkshopViewWorkshopRequest == nil {
		return localVarReturnValue, nil, reportError("modWorkshopViewWorkshopRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modWorkshopViewWorkshopRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
