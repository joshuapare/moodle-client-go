/*
Moodle Webservice API

Auto-generated OpenAPI spec for Moodle's Webservice API. Requires installation of the Catalyst RESTful API plugin: https://github.com/catalyst/moodle-webservice_restful.

API version: 4.3.4
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package moodleclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// ModBigbluebuttonbnAPIService ModBigbluebuttonbnAPI service
type ModBigbluebuttonbnAPIService service

type ApiModBigbluebuttonbnCanJoinRequest struct {
	ctx context.Context
	ApiService *ModBigbluebuttonbnAPIService
	modBigbluebuttonbnCanJoinRequest *ModBigbluebuttonbnCanJoinRequest
}

func (r ApiModBigbluebuttonbnCanJoinRequest) ModBigbluebuttonbnCanJoinRequest(modBigbluebuttonbnCanJoinRequest ModBigbluebuttonbnCanJoinRequest) ApiModBigbluebuttonbnCanJoinRequest {
	r.modBigbluebuttonbnCanJoinRequest = &modBigbluebuttonbnCanJoinRequest
	return r
}

func (r ApiModBigbluebuttonbnCanJoinRequest) Execute() (*ModBigbluebuttonbnCanJoin200Response, *http.Response, error) {
	return r.ApiService.ModBigbluebuttonbnCanJoinExecute(r)
}

/*
ModBigbluebuttonbnCanJoin Returns information if the current user can join or not.

Returns information if the current user can join or not.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModBigbluebuttonbnCanJoinRequest
*/
func (a *ModBigbluebuttonbnAPIService) ModBigbluebuttonbnCanJoin(ctx context.Context) ApiModBigbluebuttonbnCanJoinRequest {
	return ApiModBigbluebuttonbnCanJoinRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModBigbluebuttonbnCanJoin200Response
func (a *ModBigbluebuttonbnAPIService) ModBigbluebuttonbnCanJoinExecute(r ApiModBigbluebuttonbnCanJoinRequest) (*ModBigbluebuttonbnCanJoin200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModBigbluebuttonbnCanJoin200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModBigbluebuttonbnAPIService.ModBigbluebuttonbnCanJoin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_bigbluebuttonbn_can_join"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modBigbluebuttonbnCanJoinRequest == nil {
		return localVarReturnValue, nil, reportError("modBigbluebuttonbnCanJoinRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modBigbluebuttonbnCanJoinRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModBigbluebuttonbnCompletionValidateRequest struct {
	ctx context.Context
	ApiService *ModBigbluebuttonbnAPIService
	modBigbluebuttonbnCompletionValidateRequest *ModBigbluebuttonbnCompletionValidateRequest
}

func (r ApiModBigbluebuttonbnCompletionValidateRequest) ModBigbluebuttonbnCompletionValidateRequest(modBigbluebuttonbnCompletionValidateRequest ModBigbluebuttonbnCompletionValidateRequest) ApiModBigbluebuttonbnCompletionValidateRequest {
	r.modBigbluebuttonbnCompletionValidateRequest = &modBigbluebuttonbnCompletionValidateRequest
	return r
}

func (r ApiModBigbluebuttonbnCompletionValidateRequest) Execute() (*CoreCohortAddCohortMembers200Response, *http.Response, error) {
	return r.ApiService.ModBigbluebuttonbnCompletionValidateExecute(r)
}

/*
ModBigbluebuttonbnCompletionValidate Validate completion

Validate completion

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModBigbluebuttonbnCompletionValidateRequest
*/
func (a *ModBigbluebuttonbnAPIService) ModBigbluebuttonbnCompletionValidate(ctx context.Context) ApiModBigbluebuttonbnCompletionValidateRequest {
	return ApiModBigbluebuttonbnCompletionValidateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreCohortAddCohortMembers200Response
func (a *ModBigbluebuttonbnAPIService) ModBigbluebuttonbnCompletionValidateExecute(r ApiModBigbluebuttonbnCompletionValidateRequest) (*CoreCohortAddCohortMembers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreCohortAddCohortMembers200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModBigbluebuttonbnAPIService.ModBigbluebuttonbnCompletionValidate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_bigbluebuttonbn_completion_validate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modBigbluebuttonbnCompletionValidateRequest == nil {
		return localVarReturnValue, nil, reportError("modBigbluebuttonbnCompletionValidateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modBigbluebuttonbnCompletionValidateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModBigbluebuttonbnEndMeetingRequest struct {
	ctx context.Context
	ApiService *ModBigbluebuttonbnAPIService
	modBigbluebuttonbnEndMeetingRequest *ModBigbluebuttonbnEndMeetingRequest
}

func (r ApiModBigbluebuttonbnEndMeetingRequest) ModBigbluebuttonbnEndMeetingRequest(modBigbluebuttonbnEndMeetingRequest ModBigbluebuttonbnEndMeetingRequest) ApiModBigbluebuttonbnEndMeetingRequest {
	r.modBigbluebuttonbnEndMeetingRequest = &modBigbluebuttonbnEndMeetingRequest
	return r
}

func (r ApiModBigbluebuttonbnEndMeetingRequest) Execute() (*CoreCohortAddCohortMembers200Response, *http.Response, error) {
	return r.ApiService.ModBigbluebuttonbnEndMeetingExecute(r)
}

/*
ModBigbluebuttonbnEndMeeting End a meeting

End a meeting

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModBigbluebuttonbnEndMeetingRequest
*/
func (a *ModBigbluebuttonbnAPIService) ModBigbluebuttonbnEndMeeting(ctx context.Context) ApiModBigbluebuttonbnEndMeetingRequest {
	return ApiModBigbluebuttonbnEndMeetingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreCohortAddCohortMembers200Response
func (a *ModBigbluebuttonbnAPIService) ModBigbluebuttonbnEndMeetingExecute(r ApiModBigbluebuttonbnEndMeetingRequest) (*CoreCohortAddCohortMembers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreCohortAddCohortMembers200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModBigbluebuttonbnAPIService.ModBigbluebuttonbnEndMeeting")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_bigbluebuttonbn_end_meeting"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modBigbluebuttonbnEndMeetingRequest == nil {
		return localVarReturnValue, nil, reportError("modBigbluebuttonbnEndMeetingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modBigbluebuttonbnEndMeetingRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest struct {
	ctx context.Context
	ApiService *ModBigbluebuttonbnAPIService
	modBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest *ModBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest
}

func (r ApiModBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest) ModBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest(modBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest ModBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest) ApiModBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest {
	r.modBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest = &modBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest
	return r
}

func (r ApiModBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest) Execute() (*ModBigbluebuttonbnGetBigbluebuttonbnsByCourses200Response, *http.Response, error) {
	return r.ApiService.ModBigbluebuttonbnGetBigbluebuttonbnsByCoursesExecute(r)
}

/*
ModBigbluebuttonbnGetBigbluebuttonbnsByCourses Returns a list of bigbluebuttonbns in a provided list of courses, if no list is provided                             all bigbluebuttonbns that the user can view will be returned.

Returns a list of bigbluebuttonbns in a provided list of courses, if no list is provided
                            all bigbluebuttonbns that the user can view will be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest
*/
func (a *ModBigbluebuttonbnAPIService) ModBigbluebuttonbnGetBigbluebuttonbnsByCourses(ctx context.Context) ApiModBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest {
	return ApiModBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModBigbluebuttonbnGetBigbluebuttonbnsByCourses200Response
func (a *ModBigbluebuttonbnAPIService) ModBigbluebuttonbnGetBigbluebuttonbnsByCoursesExecute(r ApiModBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest) (*ModBigbluebuttonbnGetBigbluebuttonbnsByCourses200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModBigbluebuttonbnGetBigbluebuttonbnsByCourses200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModBigbluebuttonbnAPIService.ModBigbluebuttonbnGetBigbluebuttonbnsByCourses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_bigbluebuttonbn_get_bigbluebuttonbns_by_courses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest == nil {
		return localVarReturnValue, nil, reportError("modBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modBigbluebuttonbnGetBigbluebuttonbnsByCoursesRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModBigbluebuttonbnGetJoinUrlRequest struct {
	ctx context.Context
	ApiService *ModBigbluebuttonbnAPIService
	modBigbluebuttonbnCanJoinRequest *ModBigbluebuttonbnCanJoinRequest
}

func (r ApiModBigbluebuttonbnGetJoinUrlRequest) ModBigbluebuttonbnCanJoinRequest(modBigbluebuttonbnCanJoinRequest ModBigbluebuttonbnCanJoinRequest) ApiModBigbluebuttonbnGetJoinUrlRequest {
	r.modBigbluebuttonbnCanJoinRequest = &modBigbluebuttonbnCanJoinRequest
	return r
}

func (r ApiModBigbluebuttonbnGetJoinUrlRequest) Execute() (*ModBigbluebuttonbnGetJoinUrl200Response, *http.Response, error) {
	return r.ApiService.ModBigbluebuttonbnGetJoinUrlExecute(r)
}

/*
ModBigbluebuttonbnGetJoinUrl Get the join URL for the meeting and create if it does not exist.

Get the join URL for the meeting and create if it does not exist.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModBigbluebuttonbnGetJoinUrlRequest
*/
func (a *ModBigbluebuttonbnAPIService) ModBigbluebuttonbnGetJoinUrl(ctx context.Context) ApiModBigbluebuttonbnGetJoinUrlRequest {
	return ApiModBigbluebuttonbnGetJoinUrlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModBigbluebuttonbnGetJoinUrl200Response
func (a *ModBigbluebuttonbnAPIService) ModBigbluebuttonbnGetJoinUrlExecute(r ApiModBigbluebuttonbnGetJoinUrlRequest) (*ModBigbluebuttonbnGetJoinUrl200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModBigbluebuttonbnGetJoinUrl200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModBigbluebuttonbnAPIService.ModBigbluebuttonbnGetJoinUrl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_bigbluebuttonbn_get_join_url"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modBigbluebuttonbnCanJoinRequest == nil {
		return localVarReturnValue, nil, reportError("modBigbluebuttonbnCanJoinRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modBigbluebuttonbnCanJoinRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModBigbluebuttonbnGetRecordingsRequest struct {
	ctx context.Context
	ApiService *ModBigbluebuttonbnAPIService
	modBigbluebuttonbnGetRecordingsRequest *ModBigbluebuttonbnGetRecordingsRequest
}

func (r ApiModBigbluebuttonbnGetRecordingsRequest) ModBigbluebuttonbnGetRecordingsRequest(modBigbluebuttonbnGetRecordingsRequest ModBigbluebuttonbnGetRecordingsRequest) ApiModBigbluebuttonbnGetRecordingsRequest {
	r.modBigbluebuttonbnGetRecordingsRequest = &modBigbluebuttonbnGetRecordingsRequest
	return r
}

func (r ApiModBigbluebuttonbnGetRecordingsRequest) Execute() (*ModBigbluebuttonbnGetRecordings200Response, *http.Response, error) {
	return r.ApiService.ModBigbluebuttonbnGetRecordingsExecute(r)
}

/*
ModBigbluebuttonbnGetRecordings Returns a list of recordings ready to be processed by a datatable.

Returns a list of recordings ready to be processed by a datatable.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModBigbluebuttonbnGetRecordingsRequest
*/
func (a *ModBigbluebuttonbnAPIService) ModBigbluebuttonbnGetRecordings(ctx context.Context) ApiModBigbluebuttonbnGetRecordingsRequest {
	return ApiModBigbluebuttonbnGetRecordingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModBigbluebuttonbnGetRecordings200Response
func (a *ModBigbluebuttonbnAPIService) ModBigbluebuttonbnGetRecordingsExecute(r ApiModBigbluebuttonbnGetRecordingsRequest) (*ModBigbluebuttonbnGetRecordings200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModBigbluebuttonbnGetRecordings200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModBigbluebuttonbnAPIService.ModBigbluebuttonbnGetRecordings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_bigbluebuttonbn_get_recordings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modBigbluebuttonbnGetRecordingsRequest == nil {
		return localVarReturnValue, nil, reportError("modBigbluebuttonbnGetRecordingsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modBigbluebuttonbnGetRecordingsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModBigbluebuttonbnGetRecordingsToImportRequest struct {
	ctx context.Context
	ApiService *ModBigbluebuttonbnAPIService
	modBigbluebuttonbnGetRecordingsToImportRequest *ModBigbluebuttonbnGetRecordingsToImportRequest
}

func (r ApiModBigbluebuttonbnGetRecordingsToImportRequest) ModBigbluebuttonbnGetRecordingsToImportRequest(modBigbluebuttonbnGetRecordingsToImportRequest ModBigbluebuttonbnGetRecordingsToImportRequest) ApiModBigbluebuttonbnGetRecordingsToImportRequest {
	r.modBigbluebuttonbnGetRecordingsToImportRequest = &modBigbluebuttonbnGetRecordingsToImportRequest
	return r
}

func (r ApiModBigbluebuttonbnGetRecordingsToImportRequest) Execute() (*ModBigbluebuttonbnGetRecordingsToImport200Response, *http.Response, error) {
	return r.ApiService.ModBigbluebuttonbnGetRecordingsToImportExecute(r)
}

/*
ModBigbluebuttonbnGetRecordingsToImport Returns a list of recordings ready to import to be processed by a datatable.

Returns a list of recordings ready to import to be processed by a datatable.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModBigbluebuttonbnGetRecordingsToImportRequest
*/
func (a *ModBigbluebuttonbnAPIService) ModBigbluebuttonbnGetRecordingsToImport(ctx context.Context) ApiModBigbluebuttonbnGetRecordingsToImportRequest {
	return ApiModBigbluebuttonbnGetRecordingsToImportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModBigbluebuttonbnGetRecordingsToImport200Response
func (a *ModBigbluebuttonbnAPIService) ModBigbluebuttonbnGetRecordingsToImportExecute(r ApiModBigbluebuttonbnGetRecordingsToImportRequest) (*ModBigbluebuttonbnGetRecordingsToImport200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModBigbluebuttonbnGetRecordingsToImport200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModBigbluebuttonbnAPIService.ModBigbluebuttonbnGetRecordingsToImport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_bigbluebuttonbn_get_recordings_to_import"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modBigbluebuttonbnGetRecordingsToImportRequest == nil {
		return localVarReturnValue, nil, reportError("modBigbluebuttonbnGetRecordingsToImportRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modBigbluebuttonbnGetRecordingsToImportRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModBigbluebuttonbnMeetingInfoRequest struct {
	ctx context.Context
	ApiService *ModBigbluebuttonbnAPIService
	modBigbluebuttonbnMeetingInfoRequest *ModBigbluebuttonbnMeetingInfoRequest
}

func (r ApiModBigbluebuttonbnMeetingInfoRequest) ModBigbluebuttonbnMeetingInfoRequest(modBigbluebuttonbnMeetingInfoRequest ModBigbluebuttonbnMeetingInfoRequest) ApiModBigbluebuttonbnMeetingInfoRequest {
	r.modBigbluebuttonbnMeetingInfoRequest = &modBigbluebuttonbnMeetingInfoRequest
	return r
}

func (r ApiModBigbluebuttonbnMeetingInfoRequest) Execute() (*ModBigbluebuttonbnMeetingInfo200Response, *http.Response, error) {
	return r.ApiService.ModBigbluebuttonbnMeetingInfoExecute(r)
}

/*
ModBigbluebuttonbnMeetingInfo Get displayable information on the meeting

Get displayable information on the meeting

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModBigbluebuttonbnMeetingInfoRequest
*/
func (a *ModBigbluebuttonbnAPIService) ModBigbluebuttonbnMeetingInfo(ctx context.Context) ApiModBigbluebuttonbnMeetingInfoRequest {
	return ApiModBigbluebuttonbnMeetingInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModBigbluebuttonbnMeetingInfo200Response
func (a *ModBigbluebuttonbnAPIService) ModBigbluebuttonbnMeetingInfoExecute(r ApiModBigbluebuttonbnMeetingInfoRequest) (*ModBigbluebuttonbnMeetingInfo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModBigbluebuttonbnMeetingInfo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModBigbluebuttonbnAPIService.ModBigbluebuttonbnMeetingInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_bigbluebuttonbn_meeting_info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modBigbluebuttonbnMeetingInfoRequest == nil {
		return localVarReturnValue, nil, reportError("modBigbluebuttonbnMeetingInfoRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modBigbluebuttonbnMeetingInfoRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModBigbluebuttonbnUpdateRecordingRequest struct {
	ctx context.Context
	ApiService *ModBigbluebuttonbnAPIService
	modBigbluebuttonbnUpdateRecordingRequest *ModBigbluebuttonbnUpdateRecordingRequest
}

func (r ApiModBigbluebuttonbnUpdateRecordingRequest) ModBigbluebuttonbnUpdateRecordingRequest(modBigbluebuttonbnUpdateRecordingRequest ModBigbluebuttonbnUpdateRecordingRequest) ApiModBigbluebuttonbnUpdateRecordingRequest {
	r.modBigbluebuttonbnUpdateRecordingRequest = &modBigbluebuttonbnUpdateRecordingRequest
	return r
}

func (r ApiModBigbluebuttonbnUpdateRecordingRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ModBigbluebuttonbnUpdateRecordingExecute(r)
}

/*
ModBigbluebuttonbnUpdateRecording Update a single recording

Update a single recording

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModBigbluebuttonbnUpdateRecordingRequest
*/
func (a *ModBigbluebuttonbnAPIService) ModBigbluebuttonbnUpdateRecording(ctx context.Context) ApiModBigbluebuttonbnUpdateRecordingRequest {
	return ApiModBigbluebuttonbnUpdateRecordingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ModBigbluebuttonbnAPIService) ModBigbluebuttonbnUpdateRecordingExecute(r ApiModBigbluebuttonbnUpdateRecordingRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModBigbluebuttonbnAPIService.ModBigbluebuttonbnUpdateRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_bigbluebuttonbn_update_recording"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modBigbluebuttonbnUpdateRecordingRequest == nil {
		return localVarReturnValue, nil, reportError("modBigbluebuttonbnUpdateRecordingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modBigbluebuttonbnUpdateRecordingRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModBigbluebuttonbnViewBigbluebuttonbnRequest struct {
	ctx context.Context
	ApiService *ModBigbluebuttonbnAPIService
	modBigbluebuttonbnViewBigbluebuttonbnRequest *ModBigbluebuttonbnViewBigbluebuttonbnRequest
}

func (r ApiModBigbluebuttonbnViewBigbluebuttonbnRequest) ModBigbluebuttonbnViewBigbluebuttonbnRequest(modBigbluebuttonbnViewBigbluebuttonbnRequest ModBigbluebuttonbnViewBigbluebuttonbnRequest) ApiModBigbluebuttonbnViewBigbluebuttonbnRequest {
	r.modBigbluebuttonbnViewBigbluebuttonbnRequest = &modBigbluebuttonbnViewBigbluebuttonbnRequest
	return r
}

func (r ApiModBigbluebuttonbnViewBigbluebuttonbnRequest) Execute() (*CoreCalendarDeleteSubscription200Response, *http.Response, error) {
	return r.ApiService.ModBigbluebuttonbnViewBigbluebuttonbnExecute(r)
}

/*
ModBigbluebuttonbnViewBigbluebuttonbn Trigger the course module viewed event and update the module completion status.

Trigger the course module viewed event and update the module completion status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModBigbluebuttonbnViewBigbluebuttonbnRequest
*/
func (a *ModBigbluebuttonbnAPIService) ModBigbluebuttonbnViewBigbluebuttonbn(ctx context.Context) ApiModBigbluebuttonbnViewBigbluebuttonbnRequest {
	return ApiModBigbluebuttonbnViewBigbluebuttonbnRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreCalendarDeleteSubscription200Response
func (a *ModBigbluebuttonbnAPIService) ModBigbluebuttonbnViewBigbluebuttonbnExecute(r ApiModBigbluebuttonbnViewBigbluebuttonbnRequest) (*CoreCalendarDeleteSubscription200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreCalendarDeleteSubscription200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModBigbluebuttonbnAPIService.ModBigbluebuttonbnViewBigbluebuttonbn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mod_bigbluebuttonbn_view_bigbluebuttonbn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modBigbluebuttonbnViewBigbluebuttonbnRequest == nil {
		return localVarReturnValue, nil, reportError("modBigbluebuttonbnViewBigbluebuttonbnRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modBigbluebuttonbnViewBigbluebuttonbnRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
